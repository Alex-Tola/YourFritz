#! /bin/sh
################################################################################
#                                                                              #
# Modify root file system directly at an AVM FRITZ!Box router device           #
#                                                                              #
# Copyright (C) 2014 P.Haemmerlein (http://www.yourfritz.de)                   #
#                                                                              #
# This program is free software; you can redistribute it and/or                #
# modify it under the terms of the GNU General Public License                  #
# as published by the Free Software Foundation; either version 2               #
# of the License, or (at your option) any later version.                       #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License under                                             #
# http://www.gnu.org/licenses/gpl-2.0.html                                     #
# for more details.                                                            #
#                                                                              #
# "FRITZ!Box" and "FRITZ!" are registered word marks and "AVM" is a registered #
# word and figurative mark of:                                                 #
# AVM Computersysteme Vertriebs GmbH, 10559, Berlin, DE.                       #
#                                                                              #
################################################################################
#
# AVM "constants"
#
# procfs of MTD driver
procmtd="/proc/mtd" 
# device name of MTD partition for access with character oriented I/O
mtdprefix="mtd" 
# device name of MTD partitions for access with block oriented I/O
mtdblockname="mtdblock" 
# prefix for inactive partition names
reservedprefix="reserved-" 
# name of kernel partition
kernelname="kernel" 
# name of file system partition
filesystemname="filesystem" 
# name of the partition with NAND flash available to the user
nandname="nand-filesystem" 
# environment file name within the TFFS procfs
envpathname="/proc/sys/urlader/environment" 
# variable used to switch between boot time systems
fsvarname="linux_fs_start" 
# hardware revision variable name
hwrevname="HWRevision" 
# supported hardware revisions
# 3370, 7362SL, 3390, 7490, 3490
hwrevs_supported="175 185 193 203 212" 
# AVM's binary to modify the NAND based partitions (busybox has it's own tools, but not ooB on a device with original firmware)
update_kernel_binary="/sbin/update_kernel" 
# where is the wrapper mounted at the running system ?
wrapperdir="/wrapper" 
# the file name of the root file system image
rootfsname="filesystem_core.squashfs" 
# the name of a firmware image, it will be renamed during download
firmwarestoragename="firmware.image" 
# the kernel image name within a firmware image
firmware_kernel_image="./var/tmp/kernel.image" 
# the wrapper file system image name within a firmware image
firmware_filesystem_image="./var/tmp/filesystem.image" 
# wrapper file system image file name
wrapperimagename="filesystem.image"
# kernel image file name
kernelfilename="kernel.image"
# the name of the file, which can be used to determine the version of the system within a squashfs image
versionfilename="/etc/version" 
# the name of the shell on the box
shl="/bin/sh"
# blkid executable path
blkid="/usr/sbin/blkid"
# the name of the ring buffer utility from the vendor
debugoutput="/bin/showshringbuf -i \$scriptname"
# our debug ring buffer file name
ringbufferfile="/var/.srb_\$scriptname"
#
# the correct FTP download path is model and version dependent
# one path entry is required for every supported hardware revision (ftp_path_${hwrev})
#
ftp_server="download.avm.de"
ftp_path_175="/fritz.box/fritzbox.wlan_3370/firmware/deutsch/fritz.box_wlan_3370.\$version.image"
ftp_path_185="/fritz.box/fritzbox.7490/firmware/deutsch/FRITZ.Box_7490.\$version.image"
ftp_path_193="/fritz.box/fritzbox.wlan_3390/firmware/deutsch/FRITZ.Box_3390.\$version.image"
ftp_path_203="/fritz.box/fritzbox.7362_sl/firmware/deutsch/FRITZ.Box_7362_SL.\$version.image"
ftp_path_212="/fritz.box/fritzbox.3490/firmware/deutsch/FRITZ.Box_3490.\$version.image"
# some more values which have to be changed, if AVM modifies its firmware 
#
# 128MB ext3 image plus 5 percent
free_space_for_unpack="134M" 
# 32 MB (23 MB at this time) for packed and double space for unpacked image
free_space_for_unpack_tmpfs="96M" 
# even with a small amount of RAM at all, there should be a minimum of free space
free_space_at_tmpfs="24M" 
# that's really low on space, better restart the box again
warning_space_at_tmpfs="10M" 
# one more time the space needed for our ext3 container + 5%
free_space_at_nand="134M" 
# the estimated space needed to store an extracted squashfs image at NAND
warning_space_at_nand="64M" 
# the estimated space needed to download a firmware image from the FTP server
download_space_needed="32M" 
# the estimated space needed to extract a wrapper file system from a firmware image
extract_space_needed="32M" 
# the "normal" base for temporary files and directories
tmpfsbasedir="/var/tmp" 
# known native file system types, we can use them without a container
nativefilesystems="tmpfs ext2 ext3 ext4 yaffs2" 
#
# error codes
#
#  32 - different MD5 hashes for kernel MTDs
#  33 - unable to find kernel MTD
#  34 - unable to find alternative kernel MTD
#  35 - missing linux_fs_start at environment
#  36 - unsupported hardware revision
#  37 - system modified already, restart needed
#  38 - specified squashfs source file not found
#  39 - unable to extract wrapper image from firmware archive
#  40 - unable to mount wrapper file system
#  41 - unable to copy root image from wrapper
#  42 - unable to download firmware image from manufacturer
#  43 - error downloading firmware image (file size is 0)
#  44 - error copying kernel image to alternative partition
#  45 - error copying wrapper file system to alternative partition
#  46 - unknown error copying running system to inactive partitions
#  47 - unable to get hardware revision
#  48 - unable to find file system MTD partition
#  49 - unable to find alternative file system MTD partition
#  50 - not enough free space available at tmpfs
#  51 - unable to find free space for unpacking of squashfs
#  52 - unable to find free space for squashfs extraction from image
#  53 - error saving permanent copy of source squashfs image
#  54 - error unpacking loopback device image
#  55 - error mounting loopback device image
#  56 - error unmounting loopback device image
#  57 - error removing loopback device image
#  58 - not enough free space on any storage volume
#  66 - the message file was not found after fallback to 'en'
# 127 - internal error
#
# our "internal" constants
#
modfs_version=0.3.1-01082015
modfs_comment="first version from new branch with integrated debug logging"
bindirname="bin"
localedirname="locale"
filesdirname="files"
scriptdirname="modscripts"
tmpdirbase="/var/tmp"
packedpartition="128MB_ext3.gz"
squashfsdirname="squashfs-root"
showprogress=0
msgtext_clearscreen="\x1B[2J\x1B[0;0H"
msgtext_normal="\x1B[0m"
msgtext_bold="\x1B[1m"
msgtext_error="\x1B[1;31m"
msgtext_ok="\x1B[1;32m"
msgtext_warning="\x1B[1;33m"
msgtext_highlight="\x1B[1;34m"
msgtext_CR="\r\x1B[K"
#
# name and relative path of squashfs tools
#
sq_version=3 # default version
sq_pack="\$(bindir)/mksquashfs\${sq_version}"
sq_unpack="\$(bindir)/unsquashfs\${sq_version}"
#
# universal functions
#
# check, if a list contains an item and return its index (based on 1)
# $1 - the item to look for (needle)
# $2 - the haystack
#
index_of_item()
{
	local item i=0
	for item in $2; do
		let i+=1
		[ x"$1" == x"$item" ] && echo $i && return 0
	done
	return 1
}
#
# get binaries subdirectory name
#
bindir() { echo "$scriptpath/$bindirname/$(get_hardware_revision)"; }
#
# get locale subdirectory name
#
localedir() { echo "$scriptpath/$localedirname"; }
#
# get files subdirectory name
#
filesdir() { echo "$scriptpath/$filesdirname"; }
#
# remove temporary file
# $1 - file name
#
remove_temp_file()
{
	local rc
	[ -z "$1" ] && return 127
	[ ${#1} -lt 10 ] && return 127
	rm "$1" 2>/dev/null
	rc=$?
	sed -e "\|^rm *$1\$|d" -i $tempfilelist
	debug "remove_temp_file: file=$1, rc=$rc"
	return 0
}
#
# remove directory and its reference from cleanup list too
# $1 - directory to remove
#
remove_directory()
{
	local dir="$1" rc
	[ ${#1} -lt 10 ] && return 127
	rm -r $dir 2>/dev/null
	rc=$?
	sed -e "\|^rm -r *$dir\$|d" -i $tempfilelist
	debug "remove_directory: directory=$1, rc=$rc"
	return 0
}
#
# get temporary directory name
#
get_temp_dir() 
{
	local name="$tmpdirbase/$$_$(date +%s)"
	mkdir -p "$name"
	echo "rm -r $name" >>$tempfilelist
	debug "get_temp_dir: directory=$name"
	echo "$name"
	return 0
}
#
# get temporary file name
# $1 - optional base directory name
#
get_temp_file() 
{ 
	local name="$1" dir out
	dir="$(get_temp_dir)"
	[ -z "$name" ] && out="$dir/$(date +%s)" || out="$dir/$name"
	echo "rm $out" >>$tempfilelist
	debug "get_temp_file: file=$out"
	echo "$out"
	return 0
}
#
# write to debug ring buffer
# stdin -> lines to append to the buffer
# 
debug() 
{ 
	[ $MODFS_DEBUG -ne 1 ] && return 
	echo -e "$@" | sed -e ':x;$!N;s/\n/{LF}/;tx' | $debugoutput
}
#
# get next system index from environment
#
get_system_switch() { sed -n -e "s/^$fsvarname\t\([01]\)/\1/p" $envpathname; }
#
# get hardware revision from environment (it has not to be a number !)
#
get_hardware_revision() { sed -n -e "s/^$hwrevname\t\(.*\)/\1/p" $envpathname; }
#
# check, if the specified hardware revision is supported 
# $1 - hardware revision
#
check_hardware_revision() { return $(index_of_item "$1" "$hwrevs_supported"); }
#
# check MTD "name"
# $1 - MTD index number
# $2 - expected MTD name from /proc/mtd
#
check_mtd() { grep "$mtdprefix$1: [0-9a-f]* [0-9a-f]* \"\($reservedprefix\)*$2\"" $procmtd; }
#
# get MTD number by name
# $1 - requested MTD partition name
#
get_mtd_by_name() { sed -n -e "s|$mtdprefix\([0-9]\{1,2\}\): [0-9a-f]\{8\} [0-9a-f]\{8\} \"$1\"|\1|p" $procmtd; }
#
# get MTD name by number
# $1 - requested MTD partition number
#
get_mtd_by_number() { sed -n -e "s|$mtdprefix$1: [0-9a-f]\{8\} [0-9a-f]\{8\} \"\(.*\)\"|\1|p" $procmtd; }
#
# build MTD partition groups
#
build_partitions()
{
	local g1 g2
	g1=$(get_mtd_by_name $kernelname):$(get_mtd_by_name $filesystemname)
	g2=$(get_mtd_by_name $reservedprefix$kernelname):$(get_mtd_by_name $reservedprefix$filesystemname)
	if [ ${g1:0:1} -lt ${g2:0:1} ]; then
		echo "$g1 $g2"
	else
		echo "$g2 $g1"
	fi
}
#
# convert string to upper case
# $@ - string(s) to convert
#
uppercase() { echo "$@" | tr 'abcdefghijklmnopqrstuvwxyzäöü' 'ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÜ'; }
#
# escape a string to use it within a regular expression without any hassle
#
escape_regexp() { echo "$@" | sed -e 's/\./\\./g'; }
#
# get localized strings (to make it easier for german users)
# - the message text may contain the macros '%{error}', '%{ok}', '%{warning}' and 
#   '%{normal}' to change text color
# - to insert variable parts into the text, the 'printf' command will be used with
#   the specified parameters (shifted two times to remove our own arguments)
# $1 - language index (ISO 639-1 code)
# $2 - message id
# $3-$n - values to substitute
#
get_localized()
{
	local lang=$1 lcfile=$(localedir)/$lang msgno=$2 rc=0 msg
	shift 2
	msg=$(sed -n -e "/^$msgno=/s/^[0-9]*=\(.*\)/\1/p" $lcfile | sed -e "s/%{error}/\${msgtext_error}/g" | sed -e "s/%{ok}/\${msgtext_ok}/g" | sed -e "s/%{warning}/\${msgtext_warning}/g" | sed -e "s/%{bold}/\${msgtext_bold}/g" | sed -e "s/%{normal}/\${msgtext_normal}/g" | sed -e "s/%{highlight}/\${msgtext_highlight}/g")
	if [ ${#msg} -eq 0 ]; then
		echo "The specified message number $msgno was not found at the language file for '$lang'." 1>&2
		rc=1
	else
        eval "printf \"$msg\" "$@""
	fi
	return $rc
}
#
# get a yes or no decision from the user
# $1 - default answer to assume, if only return is pressed
# $2 - the question to display first
# - to avoid a default answer (return key), use any other default than 'y' or 'n'
#
ask_yes_or_no()
{
	local def=$1 yes no p_yes p_no answer nl prompt="$2"
	yes=$(get_localized $lang 129)
	no=$(get_localized $lang 130)
	p_yes=$yes
	p_no=$no
	if [ $def == n ]; then
		p_no=$(uppercase $no)
	else
		if [ $def == y ]; then
			p_yes=$(uppercase $yes)
		fi
	fi
	# 1 -eq 1 is better than 'true', because 'true' is not an ash builtin in every case
	debug "ask_yes_or_no: Q=$prompt"
	while [ 1 -eq 1 ]; do
		while read -n 10 -s -t 1; do :; done
		echo -ne "$prompt" 1>&2
		read -n 1 -s -p " ($p_yes/$p_no) " answer 1>&2
		nl="$answer\n"
		[ ${#answer} -eq 0 ] && answer=$def && nl="\n"
		debug "ask_yes_or_no: A=$answer"
		if [ $answer == $(uppercase $yes) -o $answer == $yes ]; then
			echo -n 'Y'
			echo -e -n "$nl" 1>&2
			return 0
		else
			if [ $answer == $(uppercase $no) -o $answer == $no ]; then
				echo -n  'N'
				echo -e -n "$nl" 1>&2
				return 0
			else
				echo -e "$selection\n$(get_localized $lang 128)" 1>&2
			fi
		fi
	done
	return 1
}
#
# show progress messages on console
# - output will be written to stderr
# $1 - message type
#      1 - CR + show text without LF
#      2 - show text without LF
#      3 - show text with LF
#      4 - show text with LF in front of it and at the end
# $2 - message id to get localized text version
#
progress()
{
	local msg mode=$1
	shift
	msg="$(get_localized $lang "$@")"
	if [ $mode -eq 1 ]; then
		echo -ne "$msgtext_CR$msg" 1>&2
	else
		if [ $mode -eq 2 ]; then
			echo -ne "$msg" 1>&2
		else
			if [ $mode -eq 3 ]; then
				echo -ne "$msg\n" 1>&2
			else
				if [ $mode -eq 4 ]; then
					echo -ne "\n$msg\n"
				fi
			fi
		fi
	fi
	debug "progress: mode=$mode, msg=$msg"
	return
}
#
# check next system against running
#
is_switched()
{
	local nxt kernel filesys kname fname switched=1
	nxt=$(get_system_switch)
	set -- $(build_partitions)
	[ $nxt -gt 0 ] && shift
	kernel=${1%:*}
	filesys=${1#*:}
	kname="$(get_mtd_by_number $kernel)"
	fname="$(get_mtd_by_number $filesys)"
	[ "${kname:0:${#reservedprefix}}" == "$reservedprefix" ] && switched=0
	return $switched
}
#
# compare kernel checksums to make sure, the systems are identical
# $1 and $2 have to be the MTD numbers of the two kernel images
#
check_kernels()
{
	local rc=0
	if [ ${#1} -eq 0 -o ${#2} -eq 0 ];then
		rc=127
	else
		hash0=$(md5sum /dev/$mtdblockname$1 | sed -n -e 's/^\([0-9a-f]*\).*/\1/p')
		hash1=$(md5sum /dev/$mtdblockname$2 | sed -n -e 's/^\([0-9a-f]*\).*/\1/p')
		debug "check_kernels: /dev/$mtdblockname$1 = $hash0, /dev/$mtdblockname$2 = $hash1"
		if [ $hash0 != $hash1 ]; then
			rc=32
		fi
	fi
	return $rc
}
#
# call mksquashfs utility
#
sq_mksquashfs()
{
	local rc=0 binary
	binary="$(eval echo $sq_pack)"
	debug "sq_mksquashfs: $binary $@"
	$binary "$@"
	rc=$?
	debug "sq_mksquashfs: exiting, rc=$rc"
	return $rc
}
#
# call unsquashfs utility
#
sq_unsquashfs()
{
	local rc=0 binary
	binary="$(eval echo $sq_unpack)"
	debug "sq_unsquashfs: $binary $@"
	$binary "$@"
	rc=$?
	debug "sq_unsquashfs: exiting, rc=$rc"
	return $rc
}
#
# switch system selection variable to other value
#
switch_system() 
{
	local newval
	newval=$(( ( $(get_system_switch) + 1 ) % 2 ))
	echo $fsvarname $newval >$envpathname
	debug "switch_system: switched to $newval"
}
#
# switch next boot time selection to specified system, if action is really needed
# $1 - 'running' / 'alternative' to switch to the specified system based on the running version
#
switch_system_to()
{
	local next
	next=$(get_system_switch)
	debug "switch_system_to: $1"
	if is_switched; then
		if [ x"$1" == xcurrent ]; then
			switch_system
		fi
	else
		if [ x"$1" == xalternative ]; then
			switch_system
		fi
	fi
	return 0
}
#
# detect filesystem image type
# types supported: squashfs3, squashfs4, ext2, sqfs_dummy256_{type}
# $1 - source image
#
detect_image_filesystem()
{
	local src="$1" rc=222 fstype major
	fstype=$($blkid -o value -s TYPE -p $src)
	if [ x"$fstype" == x"squashfs" ]; then
		major=$(testvalue $src 2 28)
		if [ $major -eq 0 ]; then
			# dummy header
			fstype=$($blkid -o value -s TYPE -p -O 256 $src)
			if [ ${#fstype} -gt 0 ]; then
				fstype="sqfs_dummy256_$fstype"
			fi 
		else
			fstype=$fstype$major
		fi
	fi
	[ ${#fstype} -gt 0 ] && rc=0
	echo $fstype
	debug "detect_image_filesystem: src=$src, fstype=$fstype, rc=$rc"
	return $rc
}
#
# copy kernel image to alternative partition
# $1 - optional file name of the new kernel image - if omitted, the current kernel will be copied
#
copy_kernel_image()
{
	local src="$1" target rc
	if [ ${#src} -eq 0 ]; then
		src=$(get_mtd_by_name $kernelname)
		src="/dev/$mtdprefix$src"
	fi
	target=$(get_mtd_by_name $reservedprefix$kernelname)
	debug "copy_kernel_image: src=$src, target=/dev/$mtdprefix$target"
	$update_kernel_binary -i $src -o /dev/$mtdprefix$target >/dev/null 2>&1
	rc=$?
	debug "copy_kernel_image: exiting, rc=$rc"
	return $rc
}
#
# copy wrapper file system to alternative partition
#
copy_filesystem()
{
	local tmp target rc
	target=$(get_mtd_by_name $reservedprefix$filesystemname)
	$update_kernel_binary -o /dev/$mtdprefix$target >/dev/null 2>&1
	debug "copy_filesystem: /dev/$mtdprefix$target cleared"
	tmp=$(get_temp_dir)
	mount -t yaffs2 /dev/$mtdblockname$target "$tmp"
	cp -R /wrapper/* $tmp/
	rc=$?
	debug "copy_filesystem: copied everything from $tmp, rc=$rc"
	umount "$tmp"
	remove_directory "$tmp"
	debug "copy_filesystem: exiting, rc=$rc"
	return $rc
}
#
# copy running system to alternative partitions
#
copy_running_system()
{
	local rc
	# prepare MTD writes
	# notify power management
	echo MODE=update > /dev/avm_power
	# prevent unwanted watchdog restarts, may be necessary but update is very fast
	# echo "disable" > /dev/watchdog
	copy_kernel_image
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=44
	else
		copy_filesystem
		rc=$?
		if [ $rc -ne 0 ]; then
			rc=45
		fi
	fi
	debug "copy_running_system: exiting, rc=$rc"
	return $rc
}
#
# copy new wrapper file system
# $1 - source file system image
# $2 - root file system image name to be excluded from copying
#
copy_wrapper_filesystem()
{
	local rc target src="$1" tmp fstype mrc=0 kernelversion
	target=$(get_mtd_by_name $reservedprefix$filesystemname)
	# prepare MTD writes
	# notify power management
	echo MODE=update > /dev/avm_power
	# prevent unwanted watchdog restarts, may be necessary but update is very fast
	# echo "disable" > /dev/watchdog
	# clear filesystem first
	debug "copy_wrapper_filesystem: src=$src, rootfs=$rootfsname"
	$update_kernel_binary -o /dev/$mtdprefix$target >/dev/null 2>&1
	rc=$?
	debug "copy_wrapper_filesystem: clearing target device /dev/$mtdprefix$target, rc=$rc"
	if [ $rc -ne 0 ]; then
		rc=44
	else
		fstype=$(detect_image_filesystem "$src")
		rc=$?
		if [ $rc -eq 0 ]; then
			# mount squashfs and yaffs2 wrapper and copy from one to the other
			tmp="$(get_temp_dir)"
			mkdir -p $tmp/yaffs $tmp/wrapperfs
			mount -t yaffs2 /dev/$mtdblockname$target $tmp/yaffs
			if [ "$fstype" == "ext2" -o "$fstype" == "sqfs_dummy256_ext2" ]; then
				# ext2 image with AVM's dummy header
				mount_ext2_image "$src" "$tmp/wrapperfs" "$fstype"
				rc=$?
				mrc=$rc
			else
				mount "$src" $tmp/wrapperfs 2>/dev/null
				rc=$?
				mrc=$rc
				if [ $rc -ne 0 ]; then
					# try to extract with unsquashfs3, if this is a 3.xx kernel based
					# system without knowledge about SquashFS3 format while mounting
					kernelversion=$(uname -r)
					kernelversion=${kernelversion%%.*}
					if [ $kernelversion -eq 3 -a x"$fstype" == x"squashfs3" ]; then
						unpack_squashfs "$src" "$tmp" 2>&1 >/dev/null
						rc=$?
						if [ $rc -eq 0 ]; then
							rmdir "$tmp/wrapperfs"
							mv "$tmp/$squashfsdirname" "$tmp/wrapperfs"
							rc=$?
							rm "$tmp/wrapperfs/$rootfsname"
						fi
					fi
				fi
			fi
			if [ $rc -eq 0 ]; then
				tar -c -O -C $tmp/wrapperfs --exclude=$rootfsname . | tar -x -C $tmp/yaffs
				rc=$?
				debug "copy_wrapper_filesystem: copying done, rc=$rc"
				[ $mrc -eq 0 ] && umount $tmp/wrapperfs
				umount $tmp/yaffs
				remove_directory "$tmp"
				rc=0
			fi
		fi
	fi
	debug "copy_wrapper_filesystem: exiting, rc=$rc"
	return $rc
}
#
# copy new root file system to alternative wrapper partition
# $1 - file name of new root file system image
#
copy_new_root_filesystem()
{
	local src="$1" target tmp
	target=$(get_mtd_by_name $reservedprefix$filesystemname)
	tmp="$(get_temp_dir)"
	debug "copy_new_root_filesystem: src=$src, target=/dev/$mtdblockname$target"
	mount -t yaffs2 /dev/$mtdblockname$target "$tmp"
	cp -a "$src" "$tmp/$rootfsname"
	rc=$?
	umount "$tmp"
	remove_directory "$tmp"
	debug "copy_new_root_filesystem: exiting, rc=$rc"
	return $rc
}
#
# get squash file system block size
# $1 - source file system name
#
get_squashfs_blocksize() 
{
	local bs sq_version
	sq_version=$(get_squashfs_tools_version "$1")
	debug "get_squashfs_blocksize: using SquashFS version $sq_version"
	bs=$(sq_unsquashfs -s "$1" 2>/dev/null | sed -n -e "s/^Block size \(.*\)/\1/p")
	debug "get_squashfs_blocksize: block size=$bs"
	echo $bs
}
#
# get squash file system block size
# $1 - source file system name
#
get_squashfs_endianess()
{ 
	local endianess=0 endian sq_version
	sq_version=$(get_squashfs_tools_version "$1")
	debug "get_squashfs_endianess: using SquashFS version $sq_version"
	endian=$(sq_unsquashfs -s "$1" 2>/dev/null | sed -n -e "s/Found a valid \(big\|litte\) endian SQUASHFS.*/\1/p")
	[ ${#endian} -gt 0 ] && [ x"$endian" == xlittle ] && endianess=1
	debug "get_squashfs_endianess: $endian endian"
	echo $endianess
	return 0
}
#
# unpack squash file system
# $1 - source file system name
# $2 - target directory (has to exist)
# $3 - optional file with list of names to unpack
#
unpack_squashfs()
{
	local src="$1" target="$2" files="$3" popd rc sq_version
	if [ -r "$src" ]; then
		sq_version=$(get_squashfs_tools_version "$src")
		debug "unpack_squashfs: using SquashFS version $sq_version"
		[ -z $files ] || files="-e $files"
		popd="$(pwd)"
		cd "$target"
		sq_unsquashfs -info "$src" $files 
		rc=$?
		cd "$popd"
	else
		rc=38
	fi
	debug "unpack_squashfs: exiting, rc=$rc"
	return $rc
}
#
# pack squash file system image from source tree
# $1 - source directory
# $2 - target file name
# $3 - endianess (0 - BE, 1 - LE)
# $4 - block size
#
pack_squashfs()
{
	local src="$1" target="$2" endian blocksize="$4" popd rc sq_version=$5
	if [ $sq_version -eq 3 ]; then
		[ $3 -eq 0 ] && endian="-be" || endian="-le"
	else
		endian=""
	fi
	popd="$(pwd)"
	debug "pack_squashfs: using SquashFS version $sq_version"
	cd "$src"
	sq_mksquashfs squashfs-root "$target" -info -b $blocksize $endian -force-uid 0 -force-gid 0
	rc=$?
	cd "$popd"
	debug "pack_squashfs: exiting, rc=$rc"
	return $rc
}
#
# check, if an option is supported
# $1 - option to look for
# $2 - options from script
is_supported()
{
	local option="$1" options="$2" opt rc=0
	for opt in $options; do
		curr="$opt"
		if [ $(expr index "\(" "$opt") -gt 0 ]; then
			opt="${opt%%(*)}"
		fi
		if [ x"$opt" == x"$option" ]; then
			echo "$curr"
			rc=1
			break
		fi
	done
	debug "is_supported: option=$option, from=$options, rc=$rc"
	return $rc
}
#
# execute a modscript without further user interaction
# $1 - script name
# $2 - root file system directory
# $3 - mode (auto / onrequest)
#
execute_modscript()
{
	local script="$1" scriptname="${script##*/}" rootdir="$2" mode="$3" rc=0 supports name language uselang languages header opt msg
	debug "execute_modscript: script=$script, root=$rootdir, mode=$mode"
	header="$(sed -n -e "1p" "$script")"
	if [ x"$header" == x"# MODFS_MODSCRIPT" ]; then
		supports="$(sed -n -e "s/^# SUPPORTS \(.*\)/\1/p" "$script")"
		name="$(sed -n -e "s/^# NAME \(.*\)/\1/p" "$script")"
		name="${name// /\\ }"
		if [ ${#name} -gt 0 -a ${#supports} -gt 0 ]; then
			if [ x"$mode" == xauto ]; then
				echo -e "$(get_localized $lang 172 "$name")" 1>&2
				progress 1 173	
			fi
			language="$(is_supported 'language' "$supports")"
			if [ $? -eq 1 ]; then
				languages="${language##language(}"
				languages="${languages%)}"
				uselang=$(IFS=, set -- $languages; for lng in $@; do [ $lng == $lang ] && echo $lng && break; done)
				if [ ${#uselang} -eq 0 ]; then
					[ x"$mode" == xauto ] && progress 3 174
					uselang=en
				else
					[ x"$mode" == xauto ] && progress 3 96
				fi
			else
				[ x"$mode" == xauto ] && progress 3 174
				uselang=en
			fi
			progress 1 175
			opt=$(is_supported 'precheck' "$supports")
			if [ $?	-eq 1 ]; then
				# execute pre check
				msg="$($shl $script $uselang $rootdir $mode precheck 2>&1)"
				rc=$?
				if [ $rc -gt 0 ]; then
					progress 3 177 $rc
					echo "$msg" 1>&2
				else
					progress 3 96
					[ ${#msg} -gt 0 ] && echo -e "$msg" 1>&2
				fi
			else
				progress 3 176
			fi
			if [ $rc -eq 0 ]; then
				progress 1 178
				msg="$($shl $script $uselang $rootdir $mode install 2>&1)"
				rc=$?
				if [ $rc -gt 0 ]; then
					progress 3 177 $rc
					echo "$msg" 1>&2
				else
					progress 3 96
					[ ${#msg} -gt 0 ] && echo -e "$msg" 1>&2
					progress 1 179
					opt=$(is_supported 'postcheck' "$supports")
					if [ $?	-eq 1 ]; then
						# execute post check
						msg="$($shl $script $uselang $rootdir $mode postcheck 2>&1)"
						rc=$?
						if [ $rc -gt 0 ]; then
							progress 3 177 $rc
							echo "$msg" 1>&2
						else
							progress 3 96
							[ ${#msg} -gt 0 ] && echo -e "$msg" 1>&2
						fi
					else
						progress 3 176
					fi
				fi
			fi
		else
			echo -e "$(get_localized $lang 60 "$scriptname")" 1>&2
			rc=60
		fi
	else
		echo -e "$(get_localized $lang 61 "${scriptname}")" 1>&2
		rc=61
	fi
	echo -e "$(get_localized $lang 180 "${name:-$scriptname}" $rc)" 1>&2
	debug "execute_modscript: exiting, rc=$rc"
	return $rc
}
#
# read description with the specified language from script file
# $1 - language
# $2 - script file
#
get_description()
{
	local language="$1" script="$2" rc=0 append=0 tempdir tempfile line
	tempdir="$(get_temp_dir)"
	tempfile="$tempdir/$(date +%s)"
	sed -n -e "/^# MODFS_MODSCRIPT\$/,/^# EOH\$/p" $script | sed -e "1d;\$d;/^# SUPPORTS.*\$/d;/^# NAME.*\$/d" >"$tempfile"
	while read line; do
		if [ x"${line:0:13}" == x"# DESCRIPTION" ]; then
			if [ $language == - ]; then
				if [ x"$line" == x"# DESCRIPTION" ]; then
					append=1
				else
					append=0
				fi
			else
				if [ x"$line" == x"# DESCRIPTION $language" ]; then
					append=1
				else
					append=0
				fi
			fi
		else
			if [ $append -eq 1 ]; then
				description="$description${description:+\n}${line:2}"
			fi
		fi
	done <"$tempfile"
	rm "$tempfile"
	remove_directory "$tempdir"
	debug "get_description: $description"
	echo "$description"
	return $rc
}
#
# ask the user to execute a modscript
# $1 - script name
# $2 - root file system directory
#
execute_optional_modscript()
{
	local script="$1" scriptname="${script##*/}" rootdir="$2" rc=0 supports name language uselang languages header desc msg doit
	debug "execute_optional_modscript: script=$script, root=$rootdir, mode=$mode"
	header="$(sed -n -e "1p" "$script")"
	if [ x"$header" == x"# MODFS_MODSCRIPT" ]; then
		supports="$(sed -n -e "1,/^# EOH\$/s/^# SUPPORTS \(.*\)/\1/p" "$script")"
		name="$(sed -n -e "1,/^# EOH\$/s/^# NAME \(.*\)/\1/p" "$script")"
		name="${name// /\\ }"
		if [ ${#name} -gt 0 -a ${#supports} -gt 0 ]; then
			echo -e "$(get_localized $lang 172 "$name")" 1>&2
			progress 1 173	
			language="$(is_supported 'language' "$supports")"
			if [ $? -eq 1 ]; then
				languages="${language##language(}"
				languages="${languages%)}"
				uselang=$(IFS=, set -- $languages; for lng in $@; do [ $lng == $lang ] && echo $lng && break; done)
				if [ ${#uselang} -eq 0 ]; then
					progress 3 174
					uselang=en
				else
					progress 3 96
				fi
			else
				progress 3 174
				uselang=en
			fi
			sleep 1
			desc="$(sed -n -e "/^# DESCRIPTION $uselang\$/=" "$script")"
			if [ ${#desc} -eq 0 ]; then
				desc="$(sed -n -e "/^# DESCRIPTION\$/=" "$script")"
				if [ ${#desc} -eq 0 ]; then
					desc="$(get_localized $lang 181)"
				else
					desc="$(get_description - "$script")"
				fi
			else
				desc="$(get_description $uselang "$script")"
			fi
			msg="$(get_localized $lang 182 "$name" "%description%")"
			msg="${msg//%description%/$desc}"
			doit=$(ask_yes_or_no n "$msg")
			if [ x$doit == xY ]; then
				execute_modscript "$script" "$rootdir" onrequest
			fi 
		else
			echo -e "$(get_localized $lang 60 "${scriptname}")" 1>&2
			rc=60
		fi
	else
		echo -e "$(get_localized $lang 61 "${scriptname}")" 1>&2
		rc=61
	fi
	debug "execute_optional_modscript: exiting, rc=$rc"
	return $rc
}
#
# execute modification scripts
# - only execute scripts, which are "world-executable", while in batch mode
# - execute the other scripts in a 2nd step, asking the user to confirm each one
# $1 - source tree
# $2 - scripts directory
#
modify_rootfs()
{
	local target="$1" scripts="$2" rc=0 line lines lrc filelist script donelist tmpdir flags execute
	tmpdir="$(get_temp_dir)"
	# short stop to ensure an unique temporary directory name (contains the unix time)
	sleep 1
	debug "modify_rootfs: starting, target=$target, scripts=$scripts"
	filelist="$tmpdir/scripts"
	donelist="$tmpdir/executed"
	find "$scripts" -follow -xdev -type f | sort >"$filelist"
	[ -s "$filelist" ] && lines=$(sed -n -e "\$=" "$filelist") || lines=0
	line=0
	while [ $line -lt $lines ]; do
		let line+=1
		script="$(sed -n -e "${line}p" "$filelist")"
		flags=$(stat -c %a $script)
		execute=$(( ( ${flags:2:1} & 1 ) + ( ${flags:1:1} & 1 ) + ( ${flags:0:1} & 1 ) ))
		[ $execute -lt 3 ] && continue
		echo "\|^$script\$|d" >>$donelist
		execute_modscript "$script" "$target" auto
		lrc=$?
		[ $lrc -gt $rc ] && rc=$lrc
	done
	[ $line -gt 0 ] && sed -f "$donelist" -i "$filelist"
	[ -s "$filelist" ] && lines=$(sed -n -e "\$=" "$filelist") || lines=0
	line=0
	while [ $line -lt $lines ]; do
		let line+=1
		script="$(sed -n -e "${line}p" "$filelist")"
		flags=$(stat -c %a $script)
		execute=$(( ( ${flags:1:1} & 1 ) + ( ${flags:0:1} & 1 ) ))
		[ $execute -lt 2 ] && continue
		execute_optional_modscript "$script" "$target"
		lrc=$?
		[ $lrc -gt $rc ] && rc=$lrc
	done
	remove_directory "$tmpdir"
	debug "modify_rootfs: exiting, rc=$rc"
	return $rc
}
#
# extract squash file system from firmware image
# $1 - source firmware image
# $2 - target file name and path (path has to be a valid directory)
#
extract_rootfs_from_firmware()
{
	local src="$1" target="$2" tmp rc mp tmpdir
	debug "extract_rootfs_from_firmware: src=$src, target=$target"
	tmpdir="$(get_temp_dir)"
	tmp="$tmpdir/wrapperfs"
	extract_filesystem "$src" "$tmp"
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=39
	else
		sleep 1 # "hack" to ensure unique tempdir name
		mp="$(get_temp_dir)"
		mount "$tmp" "$mp"
		rc=$?
		if [ $rc -ne 0 ]; then
			rc=40
		else
			cp -a "$mp/$rootfsname" "$target"
			rc=$?
			if [ $rc -ne 0 ]; then
				rc=41
			fi
			umount "$mp"
		fi
		remove_directory "$mp"
	fi
	rm $tmp 2>/dev/null
	remove_directory "$tmpdir"
	debug "extract_rootfs_from_firmware: exiting, rc=$rc"
	return $rc
}
#
# set SquashFS version from image type
# $1 - source image
#
get_squashfs_tools_version()
{
	local src="$1" rc fstype major
	fstype=$(detect_image_filesystem "$src")
	rc=$?
	if [ $rc -eq 0 ]; then
		if [ "${fstype:0:8}" == "squashfs" ]; then
			major=${fstype#squashfs}
			echo $major
			rc=0
		fi
	fi
	debug "get_squashfs_tools_version: src=$src, version=$major"
	return $rc
}
#
# mount ext2 image using losetup with offset to avoid doubling
# the space needed to extract (as with 'dd') or use the "dd"-way
# if no losetup binary is available
# $1 - source image
# $2 - target directory name
#
mount_ext2_image()
{
	local src="$1" mp="$2" fstype="$3" rc=202 loopdev
	debug "mount_ext2_image: src=$src, mp=$mp, type=$fstype"
	if [ "$fstype" == "sqfs_dummy256_ext2" ]; then
		losetup -a >/dev/null 2>&1
		if [ $? -eq 0 ]; then
			losetup -r -f -o 256 $src 2>/dev/null
			rc=$?
			[ $rc -eq 0 ] && loopdev=$(losetup -a | sed -n -e "s|^\([^ ]*\):.*$src.*\$|\1|p")
		else
			debug "mount_ext2_image: no losetup found, using dd to remove dummy block"
			dd if="$src" of="$src.ext2" bs=256 skip=1 conv=fsync,sync 2>/dev/null
			rcdd=$?
			rcmv="?"
			if [ $rcdd -eq 0 ]; then
				mv "$src.ext2" "$src"
				rcmv=$?
			fi
			debug "mount_ext2_image: dummy header removed, dd=$rcdd, mv=$rcmv"
			loopdev="$src"
			rc=0
		fi
	else
		loopdev=$src
		rc=0
	fi
	if [ $rc -eq 0 ]; then
		mount "$loopdev" "$mp" 2>/dev/null
		rc=$?
	fi
	debug "mount_ext2_image: exiting, rc=$rc"
	return $rc
}
#
# extract squash file system from wrapper image
# $1 - source image
# $2 - target file name and path (path has to be a valid directory)
#
extract_rootfs_from_wrapper()
{
	local src="$1" target="$2" tmp rc mp tmpdir version kernelversion
	debug "extract_rootfs_from_wrapper: src=$src, target=$target"
	fstype=$(detect_image_filesystem "$src")
	rc=$?
	if [ $rc -eq 0 ]; then
		tmpdir="$(get_temp_dir)"
		if [ "$fstype" == "ext2" -o "$fstype" == "sqfs_dummy256_ext2" ]; then
			# ext2 image with AVM's dummy header
			mount_ext2_image "$src" "$tmpdir" "$fstype"
			rc=$?
		else
			mount "$src" "$tmpdir" 2>/dev/null
			rc=$?
			if [ $rc -ne 0 ]; then
				# try to extract with unsquashfs3, if this is a 3.xx kernel based
				# system without knowledge about SquashFS3 format while mounting
				kernelversion=$(uname -r)
				kernelversion=${kernelversion%%.*}
				if [ $kernelversion -eq 3 -a x"$fstype" == x"squashfs3" ]; then
					unpack_squashfs "$src" "${target%/*}" "$rootfsname" 2>&1 >/dev/null
					rc=$?
					if [ $rc -eq 0 ]; then
						mv "${target%/*}/$squashfsdirname/$rootfsname" "${target}"
						rc=$?
						rmdir "${target%/*}/$squashfsdirname"
						remove_directory "$tmpdir"
						debug "extract_rootfs_from_wrapper: exiting, rc=$rc"
						return $rc
					fi
				fi
			fi
		fi
		if [ $rc -ne 0 ]; then
			rc=40
		else
			cp -a "$tmpdir/$rootfsname" "$target"
			rc=$?
			if [ $rc -ne 0 ]; then
				rc=41
			fi
			umount "$tmpdir"
		fi
		remove_directory "$tmpdir"
	fi
	debug "extract_rootfs_from_wrapper: exiting, rc=$rc"
	return $rc
}
#
# extract kernel image from firmware image
# $1 - source firmware image
# $2 - target file name and path (path has to be a valid directory)
#
extract_kernel()
{
	local src="$1" target="$2" tmp rc mp tmpdir
	debug "extract_kernel: src=$src, target=$target"
	tar -xOf "$src" "$firmware_kernel_image" >"$target" 2>/dev/null
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=62
	fi
	debug "extract_kernel: exiting, rc=$rc"
	return $rc
}
#
# extract filesystem image from firmware image
# $1 - source firmware image
# $2 - target file name and path (path has to be a valid directory)
#
extract_filesystem()
{
	local src="$1" target="$2" tmp rc mp tmpdir
	debug "extract_filesystem: src=$src, target=$target"
	tar -xOf "$src" "$firmware_filesystem_image" >"$target" 2>/dev/null
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=39
	fi
	debug "extract_filesystem: exiting, rc=$rc"
	return $rc
}
#
# get system version
# $1 - system root
#
get_system_version() 
{ 
	local vf="$1$versionfilename" version subversion
	subversion=$($shl "$1$versionfilename" --subversion) 
	version=$($shl "$1$versionfilename" --version)
	[ ${#subversion} -gt 0 ] && echo "$version-$subversion" || echo "$version"
}
#
# download firmware file from manufacturer
# $1 - target file name
#
download_firmware()
{
	local ftppath target="$1" version="$2" hwrev rc=0
	debug "download_firmware: target=$target, version=$version"
	hwrev="$(get_hardware_revision)"
	eval ftppath="$(echo \$ftp_path_$hwrev)"
	eval ftppath="$(echo $ftppath)"
	debug "download_firmware: ftppath=$ftppath"
	ftpget $ftp_server "$target" "$ftppath" 2>/dev/null
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=42
	else
		if [ $(stat -c %s "$target") -eq 0 ]; then
			rc=43
		fi
	fi
	debug "download_firmware: exiting, rc=$rc"
	return $rc
}
#
# check space value for human readable format
# - the ash shell at the box is limited to 32-bit arithmetics, GB units are impossible
# $1 - space value (n, nK or nM)
#
get_numeric_space_value()
{
	local rc=0 number=$1 size=0 len last
	if [ ${#number} -eq 0 ]; then
		rc=127
	else
		last=${number:$(( ${#number} - 1 )):1}
		len=$(( ${#number} - 1 ))
		num=${number:0:$len}
		if [ $last == K ]; then
			size=$(( $num * 1024 ))
		else
			if [ $last == M ]; then
				size=$(( $num * 1024 * 1024 ))
			else
				size=$number
			fi
		fi
	fi
	echo $size
	return $rc
}
#
# check free tmpfs space
# $1 - free space needed for rc=0
# $2 - free space needed for rc=1
#
check_free_tmpfs()
{
	local rc=0 size bs free freespace rc1 rc2
	wanted=$(get_numeric_space_value $1)
	rc1=$?
	needed=$(get_numeric_space_value $2)
	rc2=$?
	debug "check_free_tmpfs: wanted=$wanted, needed=$needed"
	if [ $rc1 -eq 0 -a $rc2 -eq 0 ]; then
		bs=$(stat -c %S -f $tmpfsbasedir)
		free=$(stat -c %f -f $tmpfsbasedir)
		freespace=$(( bs * free ))
		if [ $freespace -lt $wanted ]; then
			if [ $freespace -lt $needed ]; then
				rc=2
			else
				rc=1
			fi
		else
			rc=0
		fi
	else
		let rc=rc1+rc2
	fi
	debug "check_free_tmpfs: exiting, rc=$rc"
	return $rc
}
#
# check, if the specified path is on volatile storage
#
is_tmpfs()
{
	local path="$1" 
	type=$(stat -c %T -f "$path")
	if [ x$type == x"tmpfs" ]; then
		echo 1
	else
		echo 0
	fi
	debug "is_tmpfs: path=$path, fs=$type"
}
#
# get nand file system mount point
#
get_nand_mountpoint()
{
	local rc=0 nandmajor nandminor device mountpoint type options x y 
	if [ $CONFIG_NAND == y ]; then
		nandminor=$(get_mtd_by_name $nandname)
		if [ ${#nandminor} -gt 0 ]; then
			nandmajor=$(sed -n -e "s/^ *\([0-9]*\) $mtdblockname/\1/p" /proc/devices)
			rc=1
			while read device mountpoint type options x y; do
				if [ x"$(stat -c %F $device 2>/dev/null)" == x"block special file" ]; then
					if [ $(( 0x$(stat -c %t $device 2>/dev/null) )) -eq $nandmajor ]; then
						if [ $(( 0x$(stat -c %T $device 2>/dev/null) )) -eq $nandminor ]; then
							echo $mountpoint
							rc=0
							break
						fi
					fi
				fi
			done </proc/mounts
		else
			rc=2
		fi
	else
		rc=2
	fi
	[ $rc -eq 0 ] && debug "get_nand_mountpoint: location=$mountpoint" || debug "get_nand_mountpoint: no NAND device found"
	return $rc
}
#
# check free nand space
# $1 - free space needed
#
check_free_nand()
{
	local rc=0 size bs free freespace
	size=$(get_numeric_space_value $1)
	rc=$?
	if [ $rc -eq 0 ]; then
		nand=$(get_nand_mountpoint)
		bs=$(stat -c %S -f $nand)
		free=$(stat -c %f -f $nand)
		freespace=$(( bs * free ))
		if [ $freespace -lt $size ]; then
			rc=1
		else
			echo "$nand:$freespace"
			rc=0
		fi
	fi
	debug "check_free_nand: size=$size, nand=$nand, free=$freespace"
	return $rc
}
#
# find USB device mount point(s)
# - print all network (block devices) or USB mount points
#
get_possible_usb_mountpoints()
{
	local device mountpoint type options x y major dev i count=0
	while read device mountpoint type options x y; do
		if [ x"$(stat -c %F $device 2>/dev/null)" == x"block special file" ]; then
			major=$(( 0x$(stat -c %t $device 2>/dev/null) ))
			dev=$(sed -e "1,/^Block devices:/d" /proc/devices | sed -n -e "s/^ *$major \(.*\)/\1/p")
			i=$(index_of_item "$dev" "loop $mtdblockname")
			if [ $? -eq 1 ]; then
				# not on loop or mtdblock - USB or network
				echo $mountpoint
				debug "get_possible_usb_mountpoints: on=$mountpoint"
				let count+=1
			fi
		fi
	done </proc/mounts
	debug "get_possible_usb_mountpoints: count=$count"
	return $count
}
#
# check space on mount points at stdin
# - stdin has to contain one line for each mount point of a file system to check
# - stdout will contain a list of all mount points with enough room and the free space available there
# $1 - free space needed
#
check_space()
{
	local needed outpath mp bs free_blocks blocks_in_K free_size unit needed_blocks
	needed=$(get_numeric_space_value $1)
	debug "check_space: needed=$needed"
	while read mp; do
		bs=$(stat -c %S -f $mp)
		free_blocks=$(stat -c %f -f $mp)
		# 32-bit arithmetics on box are a little bit annoying
		let size=$(( bs * free_blocks ))
		if [ ${#size} -gt 6 ]; then
			if [ $bs -gt 1024 ]; then
				blocks_in_K=$(( $bs / 1024 ))
				let size=$(( blocks_in_K * free_blocks ))
				if [ ${#size} -gt 6 ]; then
					# very much free space, let's try it with MBytes
					free_size=$(( free_blocks * ( bs / 1024 ) ))
					unit=K
					needed_blocks=$(( needed / bs ))
				else
					free_size=$(( blocks_in_K * free_blocks ))
					unit=K
					needed_blocks=$(( needed / bs ))
				fi
			else # block size is lower than 1K, awesome ... free_blocks seems to be very large
				free_size=$(( free_blocks / ( 1024 / bs ) ))
				unit=K
				needed_blocks=$(( needed / bs ))
			fi
		else
			free_size=$(( bs * free_blocks ))
			unit=""
			needed_blocks=$(( needed / bs ))
		fi
		if [ $free_blocks -ge $needed_blocks ]; then
			let mpcount+=1
			outpath="$outpath $mp:$free_size$unit"
		fi
	done
	debug "check_space: $outpath"
	echo "$outpath"
}
#
# find any place with enough free storage to host our ext3 image
# $1 - free space needed
# $2 - nonand -> ignore NAND storage, withnand -> NAND storage *and* other places, acceptnand -> NAND storage is able to satisfy the requirements
#
find_free_storage_space()
{
	local rc=0 needed mp mpcount=0 out bs free_blocks free_size needed_blocks unit
	needed=$(get_numeric_space_value $1)
	debug "find_free_storage_space: needed=$needed, accept=$2"
	rc=$?
	if [ $rc -eq 0 ]; then
		if [ x$2 == xnonand ]; then
			rc=1
		else
			out=$(check_free_nand $1)
			rc=$?
			if [ $rc -eq 0 ]; then
				if [ x$2 == xacceptnand ]; then
					rc=0
				else
					if [ x$2 == xwithnand ]; then
						rc=1
					fi
				fi
			fi
		fi
		if [ $rc -ne 0 ]; then
			out="$out $(get_possible_usb_mountpoints | check_space $needed)"
			if [ ${#out} -gt 0 ]; then
				echo "$out"
				rc=0
			else
				rc=1
			fi
		else
			echo "$out"
		fi
	fi
	debug "find_free_storage_space: $out"
	debug "find_free_storage_space: exiting, rc=$rc"
	return $rc
}
#
# get a readable output for free space
# $1 - space to convert to a human readable format (at least KByte, better MByte)
#
get_display_space()
{
	local input="$1" len last num output=0
	len=$(( ${#input} - 1 ))
	last=${input:$len:1} num=${input:0:$len}
	if [ $last == K ]; then
		output=$(( num / 1024 ))
	else
		if [ $last == M ]; then
			output=$num
		else
			num=$(( $num$last ))
			output=$(( num / 1024 / 1024 ))
		fi
	fi
	if [ $output -gt 10240 ]; then
		echo "$(( output / 1024 )) GB"
	else
		echo "$output MB"
	fi
	return
}
#
# ask the user to select one of the available working directories
# $1 - available mount points
#
get_path_selection()
{
	local mps="$1" msglist="$2" msg1 msg2 msg3 msg4 msg5 msg6 msg7 rc=0 letter letters="abcdefghijklmnopqrstuvwxyz" index
	set -- $msglist
	msg1=$1
	msg2=$2
	msg3=$3
	msg4=$4
	msg5=$5
	msg6=$6
	msg7=$7
	echo "$(get_localized $lang $msg1)" 1>&2
	while [ 1 -eq 1 ]; do
		echo -e "\n$(get_localized $lang $msg2)\n" 1>&2
		index=0
		answers=""
		for mp in $mps; do
			space="${mp##*:}"
			path="${mp%%:*}"
			letter=${letters:$index:1}
			freespace=$(get_display_space $space)
			device=$(sed -n -e "s|^\([^ ]*\) $path .*|\1|p" /proc/mounts)
			filesystem=$(sed -n -e "s|^[^ ]* $path \([^ ]*\) .*|\1|p" /proc/mounts)
			[ $filesystem == fuseblk ] && filesystem="NTFS_via_fuse"
			let index+=1
			line="$(get_localized $lang $msg3 "$letter" "$device" "$filesystem" "$path" "$freespace")"
			echo -e "$line" 1>&2
			answers=$answers$letter
		done
		echo -e "$(get_localized $lang $msg5)" 1>&2
		echo -ne "\n$(get_localized $lang $msg4) " 1>&2
		while read -n 10 -s -t 1; do :; done
		read -n 1 -s selection
		case $selection in
			[qQ])
				echo -e "$selection$(get_localized $lang $msg7)" 1>&2
				return 1
				;;
			*)
				if [ ${#selection} -gt 0 ]; then
					if [ $(expr index $selection $answers$(uppercase $answers)) -gt 0 ]; then
						break
					fi 
				fi
				echo -e "$selection\n$(get_localized $lang $msg6)" 1>&2
				continue
				;;
		esac
		break
	done
	echo -ne "$selection\n\n$msgtext_normal" 1>&2
	index=0
	for mp in $mps; do
		letter=${letters:$index:1}
		if [ $letter == $selection -o $(uppercase $letter) == $selection ]; then
			echo $mp
			debug "get_path_selection: selection=$letter, mp=$mp"
			return 0
		fi
		let index+=1
	done
	debug "get_path_selection: exiting, rc=1"
	return 1
}
#
# find a convenient storage place to fulfill the specified space requirements
# - the allowed places to search are 'tmpfs', 'nand', 'storage' in any order (2nd argument)
# $1 - space needed
# $2 - order of space to search
#
find_free_space()
{
	local wanted=$1 order="$2" rc=1 path
	debug "find_free_space: wanted=$wanted, order=$order"
	for place in $order; do
		case $place in
			tmpfs)
				check_free_tmpfs $wanted $wanted
				rc=$?
				if [ $rc -eq 0 ]; then
					echo $tmpfsbasedir
					debug "find_free_space: tmpfs=$tmpfsbasedir"
					break
				fi
				;;
			nand)
				path=$(check_free_nand $wanted)
				rc=$?
				if [ $rc -eq 0 ]; then
					echo ${path%%:*}
					debug "find_free_space: nand=$path"
					break
				fi
				;;
			storage)
				path="$(find_free_storage_space $wanted nonand)"
				rc=$?
				if [ $rc -eq 0 ]; then
					count=0
					for mp in $path; do
						let count+=1
					done
					if [ $count -gt 1 ]; then
						path=$(get_path_selection "$path" "122 123 124 125 126 127 131")
						rc=$?
						if [ $rc -eq 0 ]; then	
							echo ${path%%:*}
							debug "find_free_space: storage=$path"
							break
						fi						
					else
						debug "find_free_space: storage=$path"
						echo ${path%%:*}
						break
					fi
				fi
				;;
			*)
				;;
		esac
	done
	debug "find_free_space: exiting, rc=$rc"
	return $rc
}
#
# find mount point for the specified path
# $1 - path below the needed mount point
#
get_mountpoint()
{
	local path="$1" rc=0
	while [ ${#path} -gt 0 ]; do
		dev="$(sed -n -e "s|^\([^ \t]*\) $path \(.*\) \(.*\) \(.\) \(.\)|\1|p" /proc/mounts)"
		if [ ${#dev} -gt 0 ]; then
			break
		else
			path="${path%/*}"
		fi
	done
	echo $path
	debug "get_mount_point: path=$1, mp=$path"
	return $rc
}
#
# let the user select a non-volatile storage place with enough free space
#
get_persistent_path()
{
	local wanted rc=0 count
	wanted=$(get_numeric_space_value $1)
	path="$(find_free_storage_space $wanted withnand)"
	debug "get_persistent_path: wanted=$wanted"
	rc=$?
	if [ $rc -eq 0 ]; then
		count=0
		for mp in $path; do
			let count+=1
		done
		if [ $count -gt 1 ]; then
			path=$(get_path_selection "$path" "136 137 124 138 126 127 139")
			rc=$?
			if [ $rc -eq 0 ]; then	
				echo ${path%%:*}
				debug "get_persistent_path: $path"
			fi						
		else
			echo ${path%%:*}
			debug "get_persistent_path: $path"
		fi
	fi
	debug "get_persistent_path: exiting, rc=$rc"
	return $rc
}
#
# check a possible squashfs image file
# $1 - image file name
#
check_squashfs_image()
{
	local squashfsimage="$1" rc=0 sq_version fstype
	debug "check_squashfs_image: src=$squashfsimage"
	progress 1 165 "$squashfsimage"
	fstype="$(detect_image_filesystem "$squashfsimage")"
	if [ $? -eq 0 ]; then
		if [ "${fstype:0:8}" == "squashfs" ]; then
			sq_version=$(get_squashfs_tools_version "$squashfsimage")
			sq_unsquashfs -stat "$squashfsimage" 2>/dev/null 1>&2
			rc=$?
			if [ $rc -ne 0 ]; then
				progress 3 166
				echo -e "$(get_localized $lang 162 "$squashfsimage")" 1>&2
				debug "check_squashfs_image: error reading superblock"
				rc=1
			else
				progress 3 96
				debug "check_squashfs_image: found a SquashFS image with version $sq_version"
				rc=0
			fi
		else
			debug "check_squashfs_image: not a SquashFS image"
			rc=1
		fi
	else
		debug "check_squashfs_image: unable to detect image type"
		rc=1
	fi
	debug "check_squashfs_image: exiting, rc=$rc"
	return $rc
}
#
# check a possible firmware image file
# $1 - image file name
#
check_firmware_image()
{
	local firmwareimage="$1" rc=0
	debug "check_firmware_image: src=$firmwareimage"
	progress 1 167 "$firmwareimage"
	tar -tf "$firmwareimage" "$firmware_filesystem_image" 2>/dev/null 1>&2
	rc=$?
	if [ $rc -ne 0 ]; then
		progress 3 166
		# nope
		echo -e "$(get_localized $lang 163 "$firmwareimage")" 1>&2
		rc=1
	else
		progress 3 96
		# ok, let's get the filesystem image from it
		working_directory="$(get_working_directory $extract_space_needed "tmpfs nand storage")"
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			return $rc
		fi
		image_directory="$working_directory/$(date +%s)"
		mkdir -p "$image_directory"
		echo "rm -r $image_directory" >>$tempfilelist
		progress 1 132
		extract_rootfs_from_firmware "$firmwareimage" "$image_directory/$rootfsname"
		rc=$?
		if [ $rc -ne 0 ]; then
			progress 3 97	
			echo -e "$(get_localized $lang 163 "$firmwareimage")" 1>&2
			rc=1
		else
			# we've got a squashfs image file
			progress 3 96
			squashfsimage="$image_directory/$rootfsname"
			echo "$squashfsimage"
			rc=0
		fi
	fi
	debug "check_firmware_image: exiting, rc=$rc"
	return $rc
}
#
# check the embedded version script of a squashfs image
# $1 - image file name
#
check_squashfs_file_version()
{
	local squashfsimage="$1" rc=0 working_directory checkdir imageversion sq_version
	debug "check_squashfs_file_version: src=$squashfsimage"
	# check squashfs version
	working_directory="$(get_working_directory 1M "tmpfs nand storage")"
	rc=$?
	if [ $rc -ne 0 ]; then
		echo -e "$(get_localized $lang $rc)" 1>&2
		debug "check_squashfs_file_version: exiting, rc=$rc"
		exit $rc
	fi
	progress 1 168 $squashfsimage
	checkdir="$(get_temp_dir)"
	sq_version=$(get_squashfs_tools_version "$squashfsimage")
	sq_unsquashfs -dest "$checkdir/test" "$squashfsimage" "$versionfilename" 2>/dev/null 1>&2
	if [ -f "$checkdir/test$versionfilename" ]; then
		# check image version
		imageversion="$($checkdir/test$versionfilename -v)"
		if [ x$imageversion == x$(get_system_version) ]; then
			progress 3 96
			rc=0
		else
			progress 3 97
			echo -e "$(get_localized $lang 164 "$squashfsimage")" 1>&2
			rc=1
		fi
	else
		# no version file at image, usually not an original
		progress 3 97
		echo -e "$(get_localized $lang 162 "$squashfsimage")" 1>&2
		rc=1
	fi
	remove_directory "$checkdir"
	debug "check_squashfs_file_version: version=$imageversion"
	debug "check_squashfs_file_version: exiting, rc=$rc"
	return $rc
}
#
# find an appropriate image file at the specified device
# $1 - mount point
#
find_image_file()
{
	local mp="$1" squashfsimage firmwareimage rc=0 image_directory working_directory 
	debug "find_image_file: mp=$mp"
	if [ -f "$mp/$rootfsname" ]; then
		# possibly a squashfs as pattern
		squashfsimage="$mp/$rootfsname"
		check_squashfs_image "$squashfsimage"
		rc=$?
	else
		if [ -f "$mp/$firmwarestoragename" ]; then
			# possibly a firmware image as pattern
			firmwareimage="$mp/$firmwarestoragename"
			squashfsimage="$(check_firmware_image "$firmwareimage")"
			rc=$?
		else
			rc=1
		fi
	fi
	if [ $rc -eq 0 ]; then
		check_squashfs_file_version "$squashfsimage"
		rc=$?
		[ $rc -eq 0 ] && echo "$squashfsimage"
	fi
	debug "find_image_file: exiting, rc=$rc"
	return $rc
}
#
# let the user select a non-volatile storage place with an existing squashfs image
#
get_input_image_path()
{
	local rc=0 count notfound=0 path mp squashfsimage firmwareimage working_directory image_directory checkdir imageversion space letter answers filesystem device letters="abcdefghijklmno" pathinput=0 breaknow=0 pathto
	path="$(find_free_storage_space 1K withnand)"
	rc=$?
	if [ $rc -eq 0 ]; then
		count=0
		for mp in $path; do
			let count+=1
		done
		if [ $count -eq 1 ]; then
			# only one suitable place found, try to find an image there
			mp="${path%%:*}"
			squashfsimage="$(find_image_file "$mp")"
			rc=$?
			if [ $rc -eq 1 ]; then
				notfound=1
				rc=0
			fi
			echo -ne "\n" 1>&2
		else
			notfound=1
		fi
		if [ $notfound -eq 1 ]; then
			# no file found yet, let the user specify a new one or abort the execution
			echo "$(get_localized $lang 156 $firmwarestoragename $rootfsname)" 1>&2
			while [ 1 -eq 1 ]; do
				if [ $count -gt 1 ]; then
					# more than one possible place to store the pattern
					pathinput=0
					selection=""
					while [ 1 -eq 1 ]; do
						echo -e "\n$(get_localized $lang 157)\n" 1>&2
						index=0
						answers=""
						for mp in $path; do
							space="${mp##*:}"
							pathto="${mp%%:*}"
							letter=${letters:$index:1}
							device=$(sed -n -e "s|^\([^ ]*\) $pathto .*|\1|p" /proc/mounts)
							filesystem=$(sed -n -e "s|^[^ ]* $pathto \([^ ]*\) .*|\1|p" /proc/mounts)
							[ $filesystem == fuseblk ] && filesystem="NTFS_via_fuse"
							let index+=1
							line="$(get_localized $lang 158 "$letter" "$device" "$filesystem" "$pathto")"
							echo -e "$line" 1>&2
							answers=$answers$letter
						done
						echo -e "$(get_localized $lang 159)" 1>&2
						echo -e "$(get_localized $lang 160)" 1>&2
						echo -ne "\n$(get_localized $lang 161) " 1>&2
						while read -n 10 -s -t 1; do :; done
						read -n 1 -s selection
						case $selection in
							[qQ])
								echo -e "$selection$(get_localized $lang 131)" 1>&2
								return 1
								;;
							[pP])
								pathinput=1
								breaknow=1
								rc=1
								;;
							*)
								if [ ${#selection} -gt 0 ]; then
									if [ $(expr index $selection $answers$(uppercase $answers)) -gt 0 ]; then
										breaknow=1
									fi 
								else
									echo -e "$selection\n$(get_localized $lang 127)" 1>&2
									continue
								fi
								;;
						esac
						if [ x$selection == xp ]; then
							echo -ne "$selection\n$msgtext_normal" 1>&2
						else
							echo -ne "$selection\n\n$msgtext_normal" 1>&2
						fi
						[ $breaknow -eq 1 ] && break
					done
				else
					selection=a
					pathinput=0
				fi
				let count-=1
				if [ $pathinput -ne 1 ]; then
					# input was not 'p'
					index=0
					newpath=""
					for mp in $path; do
						letter=${letters:$index:1}
						if [ $letter == $selection -o $(uppercase $letter) == $selection ]; then
							# use that drive to find our file
							checked="${mp%%:*}"
							squashfsimage="$(find_image_file "$checked")"
							rc=$?
							if [ $rc -eq 0 ]; then
								# ok, we've found an image
								echo "$squashfsimage"
								count=0
							fi
						else
							# the probed path will be removed from the list
							newpath=""$newpath" "$mp""
						fi	
						let index+=1
					done
					if [ $rc -ne 0 ]; then
						# show error message and try again without the probed path
						echo -e "$(get_localized $lang 169 "$checked")" 1>&2
						path="$newpath"
						rc=1
					fi
				fi
				# we're finished, if we've found an image or the choice was 'p' or there're no more places to search
				[ $count -eq 0 -o $pathinput -eq 1 ] && echo "" 1>&2 && break
			done
			if [ $rc -eq 1 ]; then
				while [ 1 -eq 1 ]; do
					# let the user select his own source
					echo "$(get_localized $lang 170)" 1>&2
					read pathname
					if [ x"$pathname" == xq ]; then
						echo -e "$(get_localized $lang 116)" 1>&2
						rc=1
						break
					fi
					echo -ne "$msgtext_normal" 1>&2
					if [ -f "$pathname" ]; then
						check_squashfs_image "$pathname"
						rc=$?
						if [ $rc -gt 1 ]; then
							return $rc
						else
							squashfsimage="$pathname"
						fi
						if [ $rc -eq 1 ]; then
							squashfsimage="$(check_firmware_image "$pathname")"
							rc=$?
						fi
						if [ $rc -eq 0 ]; then
							check_squashfs_file_version "$squashfsimage"
							rc=$?
							if [ $rc -eq 0 ]; then
								echo "$squashfsimage"
								break
							fi
						fi
					else
						echo "$(get_localized $lang 171 "$pathname")" 1>&2
					fi
				done
			fi
		else
			# pattern image found
			echo "$squashfsimage"
			debug "get_input_image_path: $squashfsimage"
		fi
	else
		echo -e "$(get_localized $lang 58)" 1>&2
		rc=58
	fi
	debug "get_input_image_path: exiting, rc=$rc"
	return $rc
}
#
# check prerequisites
# - check hardware revision
# - find 'switch' variable at environment
# - find kernel partitions
# - compare kernel hashes
# - find filesystem partitions
#
check_prerequisites()
{
	local rc=0 nxt k1 k2 hwrev f1 f2 path
	echo -ne "$msgtext_clearscreen" 1>&2
	debug "check_prerequisites: starting checks"
	# get hardware revision
	progress 1 98
	hwrev="$(get_hardware_revision)"
	debug "check_prerequisites: hwrev=$hwrev"
	if [ ${#hwrev} -gt 0 ]; then
		progress 3 96
		# check hardware revision
		progress 1 99
		if check_hardware_revision "$hwrev"; then
			debug "check_prerequisites: unsupported hardware revision"
			progress 3 97
			msg="$(get_localized $lang 36 $hwrev)"
			echo -e "$msg\n" 1>&2
			rc=36
		else
			debug "check_prerequisites: supported hardware revision"
			progress 3 96
			# find boot time system selection switch
			progress 1 100
			nxt=$(get_system_switch)
			if [ ${#nxt} -eq 0 ]; then
				debug "check_prerequisites: system switch value missing"
				progress 3 97
				msg="$(get_localized $lang 35 $fsvarname)"
				echo -e "$msg\n" 1>&2
				rc=35
			else
				debug "check_prerequisites: system switch value is $nxt"
  				progress 3 96
				# check, if system is modified already 
				progress 1 101
				if is_switched; then
					if [ $undo_switch -eq 1 ]; then
						progress 3 96
						return 0
					else
						progress 3 97
						msg="$(get_localized $lang 37)"
						echo -e "$msg\n" 1>&2
						rc=37
					fi
				else
					if [ $undo_switch -eq 1 ]; then
						progress 3 97
						return 1
					fi
					progress 3 96
					# find kernel MTD
					progress 1 102
					k1=$(get_mtd_by_name $kernelname)
					if [ ${#k1} -eq 0 ]; then
						debug "check_prerequisites: no kernel device found"
						progress 3 97
						msg="$(get_localized $lang 33 $kernelname)"
						echo -e "$msg\n" 1>&2
						rc=33
					else
						debug "check_prerequisites: kernel device is /dev/$mtdblockname$k1"
						progress 3 96
						# find alternative kernel MTD
						progress 1 103
						k2=$(get_mtd_by_name $reservedprefix$kernelname)
						if [ ${#k2} -eq 0 ]; then
							debug "check_prerequisites: no alternative kernel device found"
							progress 3 97
							msg="$(get_localized $lang 34 $reservedprefix$kernelname)"
							echo -e "$msg\n" 1>&2
							rc=34
						else
							debug "check_prerequisites: alternative kernel device is /dev/$mtdblockname$k2"
							progress 3 96
							progress 1 104
							if [ $noversioncheck -eq 1 ]; then
								progress 3 95	
								rc=0
							else
								# compare kernel versions
								msg="$(check_kernels $k1 $k2)"
								rc=$?
								if [ $rc -eq 0 ]; then
									progress 3 96
								fi
							fi
							if [ $rc -eq 0 ]; then
								# find filesystem MTD
								progress 1 105
								f1=$(get_mtd_by_name $filesystemname)
								if [ ${#f1} -eq 0 ]; then
									debug "check_prerequisites: no filesystem device found"
									progress 3 97
									msg="$(get_localized $lang 48 $filesystemname)"
									echo -e "$msg\n" 1>&2
									rc=48
								else
									debug "check_prerequisites: filesystem device is /dev/$mtdblockname$f1"
									progress 3 96
									# find alternative filesystem MTD
									progress 1 106
									f2=$(get_mtd_by_name $reservedprefix$filesystemname)
									if [ ${#f2} -eq 0 ]; then
										debug "check_prerequisites: no alternative filesystem device found"
										progress 3 97
										msg="$(get_localized $lang 49 $reservedprefix$filesystemname)"
										echo -e "$msg\n" 1>&2
										rc=49
									else
										debug "check_prerequisites: alternative filesystem device is /dev/$mtdblockname$f2"
										progress 3 96
										# check free space at tmpfs 
										progress 1 117
										check_free_tmpfs $free_space_at_tmpfs $warning_space_at_tmpfs
										rc=$?
										if [ $rc -gt 1 ]; then
											debug "check_prerequisites: not enough free space found at tmpfs, memory pressure"
											progress 3 97
											msg="$(get_localized $lang 50)"
											echo -e "$msg\n" 1>&2
											rc=50
										else
											if [ $rc -eq 1 ]; then
												progress 3 118
											else
												progress 3 96
											fi
											# find enough free local space to unpack the squashfs image
											progress 1 119
											path=$(find_free_storage_space $free_space_for_unpack 2>/dev/null)
											rc=$?
											if [ $rc -eq 0 ]; then
												progress 3 96
											else
												debug "check_prerequisites: not enough free space for unpacking of images"
												progress 3 97
												msg="$(get_localized $lang 51 $free_space_for_unpack)"
												echo -e "$msg\n" 1>&2
												rc=51
											fi
										fi
									fi
								fi
							else
								progress 3 97
								msg="$(get_localized $lang 32)"
								echo -e "$msg\n" 1>&2
							fi
						fi
					fi
				fi
			fi
		fi
	else
		debug "check_prerequisites: unable to find hardware revision"
		progress 3 97
		msg="$(get_localized $lang 47 $hwrevname)" 1>&2
		echo -e "$msg\n" 1>&2
		rc=47
	fi
	debug "check_prerequisites: exiting, rc=$rc"
	return $rc
}
#
# get source selection
#
get_source()
{
	local source selection
	debug "get_source: starting selection"
	while [ 1 -eq 1 ]; do
		if [ $noversioncheck -eq 0 ]; then
			echo -e "\n$(get_localized $lang 110)" 1>&2
			echo -e "$(get_localized $lang 111)" 1>&2
			echo -e "$(get_localized $lang 112)" 1>&2
		else
			echo -e "\n$(get_localized $lang 184)" 1>&2
			echo -e "$(get_localized $lang 185)" 1>&2
		fi
		echo -e "$(get_localized $lang 113)" 1>&2
		echo -ne "\n$(get_localized $lang 114) " 1>&2
		while read -n 10 -s -t 1; do :; done
		read -n 1 -s selection
		if [ $noversioncheck -eq 0 ]; then
			case $selection in
				[aA])
					source=running
					;;
				[bB])
					source=download
					;;
				[cC])
					source=file
					;;
				[qQ])
					source=quit
					;;
				*)
					echo -e "$selection\n$(get_localized $lang 115)" 1>&2
					continue
					;;
			esac
			break
		else
			case $selection in
				[aA])
					source=download_update
					;;
				[bB])
					source=file_update
					;;
				[qQ])
					source=quit
					;;
				*)
					echo -e "$selection\n$(get_localized $lang 115)" 1>&2
					continue
					;;
			esac
			break
		fi
	done
	echo -ne "$selection\n$msgtext_normal" 1>&2
	echo $source
	debug "get_source: $source"
}
#
# get working directory decision from user
#
get_working_directory()
{
	local dir needed="$1" places="$2"
	dir="$(find_free_space $needed "$places")"
	if [ $? -ne 0 ]; then
		return 52
	fi
	echo "$dir"
	debug "get_working_directory: $dir"
	return 0
}
#
# compare firmware versions
#
is_newer_version()
{
	local left="$1" right left_model left_major left_minor right_model right_major right_minor
	right="$(get_system_version)"
	eval "$(echo $left | sed -n -e 's/\([0-9]\{1,3\}\)\.\([0-9]\{2\}\)\.\([0-9]\{2\}\)/left_model=\1 left_major=\2 left_minor=\3/p')"
	eval "$(echo $right | sed -n -e 's/\([0-9]\{1,3\}\)\.\([0-9]\{2\}\)\.\([0-9]\{2\}\)/right_model=\1 right_major=\2 right_minor=\3/p')"
	debug "is_newer_version: left=$left, right=$right"
	[ ${#left_model} -eq 0 -o ${#left_major} -eq 0 -o ${#left_minor} -eq 0 -o ${#right_model} -eq 0 -o ${#right_major} -eq 0 -o ${#right_minor} -eq 0 ] && return 2
	[ $left_model -ne $right_model ] && return 3
	[ $left_major -gt $right_major ] && return 0
	if [ $left_major -eq $right_major ]; then
		[ $left_minor -gt $right_minor ] && return 0
	fi
	return 1
}
#
# retrieve latest version number from FTP server
#
get_latest_version_from_ftp()
{
	local ftppath target="$1" hwrev rc=0 version filename versions
	debug "get_latest_version_from_ftp: target=$target"
	progress 1 188
	hwrev="$(get_hardware_revision)"
	eval ftppath="$(echo \$ftp_path_$hwrev)"
	version="|"
	eval ftppath="$(echo $ftppath)"
	filename="${ftppath##*/}"
	filename_prefix="${filename%|*}"
	filename_suffix="${filename##*|}"
	filename_prefix="$(escape_regexp "${filename_prefix}")"
	filename_suffix="$(escape_regexp "${filename_suffix}")"
	ftppath="${ftppath%/*}"
	version="$(wget -O - "http://$ftp_server$ftppath/" 2>/dev/null | sed -n -e "s#.*${filename_prefix}\([0-9]\{2,3\}\.[0-9]\{2\}\.[0-9]\{2\}\)${filename_suffix}.*#\1#p" | uniq | sort -nr | sed -n -e '1p')"
	if [ ${#version} -eq 0 ]; then
		progress 3 97
		progress 2 187
		rc=187
	else
		progress 3 96
		is_newer_version "$version"
		rc=$?
		if [ $rc -eq 0 ]; then
			progress 3 189 $version	
			echo "$version"
		else
			if [ $rc -eq 1 ]; then
				progress 3 190 "$(get_system_version)"
				rc=190
			else
				progress 3 191 $rc "${version}" "$(get_system_version)"
				rc=191
			fi
		fi
	fi
	debug "get_latest_version_from_ftp: exiting, rc=$rc"
	return $rc
}
#
# remove temporary directories before exiting
#
cleanup()
{
	debug "cleanup: running cleanup from file $tempfilelist"
	[ $MODFS_DEBUG -eq 1 ] && (cat $tempfilelist | $debugoutput)
	. $tempfilelist 2>/dev/null
	rm $tempfilelist 2>/dev/null
}
#
# show a spinner as progress indicator at stderr
# - each line output to stdout/stderr leads to a new position of the spinner
# $1 - working directory to build the needed FIFO
#
spinner()
{
	run_spinner()
	{
	    local index=0 positions="|/-\\"
	    while read line; do
	        char=${positions:$index:1}
	        echo -ne "\x1B[1D$char" 1>&2
	        let index+=1
	        [ $index -eq ${#positions} ] && index=0
	    done
	}
    local dir="$1" rc spin_from spinpid
    shift
	debug "run_spinner: dir=$dir, command=$@"
	echo -ne "  " 1>&2
	spin_from="$dir/$(date +%s)_$$"
    mkfifo "$spin_from"
    run_spinner <"$spin_from" &
	spinpid=$!
    "$@" >"$spin_from" 2>/dev/null
    rc=$?
	wait $spinpid
    rm "$spin_from"
	echo -ne "\x1B[2D" 1>&2
	debug "run_spinner: exiting, rc=$rc"
    return $rc
}
#
# init ring buffer file
#
init_ringbuffer_file()
{
	local file="$1" size=$2 maxoff maxstr
	maxoff=$(( size * 1024 - 1 ))
	dd if=/dev/zero of=$file bs=1024 count=$size 2>/dev/null
	# signature
	echo -ne "\\xF9\\x13\\x66\\x8E" | dd if=/proc/self/fd/0 of=$file bs=4 count=1 conv=notrunc seek=0 2>/dev/null
	# first entry
	echo -ne "\\x00\\x00\\x00\\x14" | dd if=/proc/self/fd/0 of=$file bs=4 count=1 conv=notrunc seek=1 2>/dev/null
	# last entry
	echo -ne "\\x00\\x00\\x00\\x14" | dd if=/proc/self/fd/0 of=$file bs=4 count=1 conv=notrunc seek=2 2>/dev/null
	# next entry
	echo -ne "\\x00\\x00\\x00\\x14" | dd if=/proc/self/fd/0 of=$file bs=4 count=1 conv=notrunc seek=3 2>/dev/null
	maxoff=$(printf "%08x" $maxoff)
	maxstr=""
	while [ ${#maxoff} -gt 0 ]; do
		maxstr="${maxstr}\\\\x${maxoff:0:2}"
		maxoff="${maxoff:2}"
	done
	# max. offset
	eval echo -ne "$maxstr" | dd if=/proc/self/fd/0 of=$file bs=4 count=1 conv=notrunc seek=4 2>/dev/null
	echo -n "with a $size KB buffer" 1>&2
}
#
# execution starts here, if called as shell script
#
# prepare script environment
scriptcalledbyname="$0"
scriptfile="$scriptcalledbyname"
while [ -L "$scriptfile" ]; do scriptfile="$(readlink "$scriptfile")"; done
scriptfile="$(realpath $scriptfile)"
scriptpath="${scriptfile%/*}"
scriptname="${scriptfile##*/}"
#
# check debug settings and initialize ring buffer, if necessary
#
ringbufferfile=$(eval echo $ringbufferfile)
debugoutput=$(eval echo $debugoutput)
if [ x"$MODFS_DEBUG" == x"1" ]; then
	echo -n "Using debug mode " 1>&2
	if [ x$MODFS_BUFSIZE != x ]; then
		if [ $MODFS_BUFSIZE != 8 ]; then
			debugfile="$(eval echo $ringbufferfile)"
			rm $debugfile 2>/dev/null
			init_ringbuffer_file $debugfile $MODFS_BUFSIZE
		fi
	fi
	echo -e "\n" 1>&2
else
	MODFS_DEBUG=0
fi
#
# FRITZ!Box language environment setting
#
lang=$Language
if [ ! -r $(localedir)/$lang ]; then
	echo "The localized messages file for '$lang' was not found, probing fallback to 'en'." 1>&2
	lang=en
fi
debug "modfs: starting modfs script version $modfs_version"
debug "modfs: script=$scriptcalledbyname"
if [ ! -r $(localedir)/$lang ]; then
	echo "The localized messages file for '$lang' does not exist." 1>&2
	debug "modfs: missing localization file for $lang"
	exit 66
fi
debug "modfs: using language $lang"
#
# initialize variables (unnecessary, only for the sake of good order and to get numeric instead of character values as needed)
#
working_directory=""
unpack_directory=""
loopback_host=""
baseimage=""
loopback_used=0
squashfs_blocksize=0
squashfs_endianess=0
rc=0
#
# we'll store an unlink command for all temporary directories and files here and remove it, if the target is deleted elsewhere
#
tempfilelist="$tmpfsbasedir/$$_filelist_$(date +%s)"
touch $tempfilelist
debug "modfs: using temporary file list from $tempfilelist"
trap 'cleanup' EXIT HUP
debug "modfs: cleanup trap set"
#
# check for 'undo' request, which is the only argument, what we expect
#
debug "modfs: invoked with: $@"
if [ x$1 == xundo ]; then
	undo_switch=1
	check_prerequisites
	rc=$?
	if [ $rc -eq 0 ]; then
		switchback=$(ask_yes_or_no n "$(get_localized $lang 194)")
		if [ $switchback == Y ]; then
			progress 1 152
			switch_system_to current
			progress 3 96
			echo -e "$(get_localized $lang 154)" 1>&2
			debug "modfs: undo finished, switched back to running system"
			exit 0
		else
			echo -e "$(get_localized $lang 153)" 1>&2
			debug "modfs: undo finished, abandoned switching back to running system"
			exit 1
		fi
	else
		echo -e "$(get_localized $lang 151)" 1>&2
		debug "modfs: undo finished, error $rc checking prerequisites"
		exit 1		
	fi
	exit $rc
else
	undo_switch=0
	if [ x$1 == xupdate ]; then
		noversioncheck=1
		if ! [ -z $2 ]; then
			firmware_update_file="$2"
			update_file_provided=1
		else
			update_file_provided=0
		fi
	else
		noversioncheck=0
		update_file_provided=0
	fi
	debug "modfs: noversioncheck=$noversioncheck, update_file_provided=$update_file_provided"
	[ $update_file_provided -eq 1 ] && debug "modfs: firmware_update_file=$firmware_update_file" 
fi
#
# check prerequisites first, any further action depends on them
#
check_prerequisites
prerc=$?
if [ $prerc -eq 32 ]; then
	copypart=$(ask_yes_or_no n "$(get_localized $lang 192)")
	if [ $copypart == Y ]; then
		copy_running_system
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
		else
			echo -e "$(get_localized $lang 183)" 1>&2
			[ $MODFS_DEBUG -ne 1 ] && reboot
			echo -e "Ready to reboot, but due to active debugging output exiting instead.\nCheck debug output and reboot manually." 1>&2
			exit 183
		fi
	fi
fi
[ $prerc -ne 0 ] && exit $prerc
echo -e "$(get_localized $lang 107 "$(get_system_version)")\n" 1>&2
if [ $noversioncheck -eq 1 ]; then
	if [ $update_file_provided -eq 0 ]; then
		echo -e "$(get_localized $lang 186)" 1>&2
	else
		echo -e "$(get_localized $lang 201)" 1>&2
	fi
fi
if [ $noversioncheck -eq 1 ]; then
	if [ $update_file_provided -eq 1 ]; then
		source="file_update"
	else
		source="download_update"
	fi
else
	echo -e "$(get_localized $lang 108)" 1>&2
	echo -e "$(get_localized $lang 109)" 1>&2
	source=$(get_source)
fi
debug "modfs: source=$source"
if [ $source == quit ]; then
	echo -e "$(get_localized $lang 116)" 1>&2
	exit 0
else
	echo -ne "\n" 1>&2
fi
case $source in
	running)
		# nothing to do prior to unpacking
		echo -e "$(get_localized $lang 120)\n" 1>&2
		baseimage="$wrapperdir/$rootfsname"
		debug "modfs: baseimage=$baseimage"
		debug "modfs: running system selected"
		;;
	download)
		working_directory="$(get_working_directory $download_space_needed "tmpfs nand storage")"
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			debug "modfs: unable to get working directory"
			exit $rc
		fi
		debug "modfs: working directory=$working_directory"
		progress 1 121 "$version"
		download_directory="$working_directory/$(date +%s)"
		mkdir -p "$download_directory"
		echo "rm -r $download_directory" >>$tempfilelist
		debug "modfs: download directory=$download_directory"
		download_firmware "$download_directory/$firmwarestoragename" "$(get_system_version)"
		rc=$?
		if [ $rc -ne 0 ]; then
			if [ $rc -eq 42 ]; then
				progress 3 97
				echo "$(get_localized $lang 42)" 1>&2
			else
				if [ $rc -eq 43 ]; then
					progress 3 97
					echo "$(get_localized $lang 43)" 1>&2
				fi
			fi
			exit $rc
		else
			progress 3 96
			working_directory="$(get_working_directory $extract_space_needed "tmpfs nand storage")"
			rc=$?
			if [ $rc -ne 0 ]; then
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			fi
			image_directory="$working_directory/$(date +%s)"
			mkdir -p "$image_directory"
			echo "rm -r $image_directory" >>$tempfilelist
			progress 1 132
			extract_rootfs_from_firmware "$download_directory/$firmwarestoragename" "$image_directory/$rootfsname"
			rc=$?
			if [ $rc -ne 0 ]; then
				progress 3 97
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			else
				progress 3 96
				baseimage="$image_directory/$rootfsname"
				progress 1 133
				remove_directory "$download_directory"
				progress 3 96
				copybase=$(ask_yes_or_no n "$(get_localized $lang 193)")
				if [ $copybase == Y ]; then
					target=""
					if [ $(is_tmpfs $image_directory) -eq 1 ]; then
						targetdir="$(get_persistent_path $(( $(stat -c %s "$baseimage") + 4096 )) )"
						rc=$?
						if [ $rc -eq 0 ]; then
							target=$targetdir/$rootfsname
						fi
					else
						target="$working_directory/$rootfsname"
					fi
					progress 1 134
					[ $rc -eq 0 ] && mv "$image_directory/$rootfsname" "$target"
					rc=$?
					if [ $rc -ne 0 ]; then
						progress 3 97
						if [ ${#target} -gt 0 ]; then
							echo -e "$(get_localized $lang 53)" 1>&2
							exit 53
						fi
					else
						progress 3 96
						echo -e "$(get_localized $lang 135 "$target")" 1>&2
						baseimage="$target"
						remove_directory "$image_directory"
					fi
				fi
			fi
			debug "modfs: baseimage=$baseimage"
			debug "modfs: download done"
		fi
		;;
	file)
		baseimage="$(get_input_image_path)"
		rc=$?
		if [ $rc -gt 1 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			exit $rc
		fi
		# no file name selected means abort execution, an error message was already displayed
		[ ${#baseimage} -eq 0 ] && rc=1
		debug "modfs: baseimage=$baseimage"
		debug "modfs: file selection done"
		;;
	download_update)
		version="$(get_latest_version_from_ftp)"
		rc=$?
		if [ $rc -eq 0 ]; then
			working_directory="$(get_working_directory $download_space_needed "tmpfs nand storage")"
			rc=$?
			if [ $rc -ne 0 ]; then
				debug "modfs: unable to get working directory"
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			fi
			debug "modfs: working directory=$working_directory"
			progress 1 121 "$version"
			download_directory="$working_directory/$(date +%s)"
			mkdir -p "$download_directory"
			echo "rm -r $download_directory" >>$tempfilelist
			debug "modfs: download directory=$download_directory"
			download_firmware "$download_directory/$firmwarestoragename" "$version"
			rc=$?
			if [ $rc -ne 0 ]; then
				if [ $rc -eq 42 ]; then
					progress 3 97
					echo "$(get_localized $lang 42)" 1>&2
				else
					if [ $rc -eq 43 ]; then
						progress 3 97
						echo "$(get_localized $lang 43)" 1>&2
					fi
				fi
				exit $rc
			else
				progress 3 96
				working_directory="$(get_working_directory $extract_space_needed "tmpfs nand storage")"
				rc=$?
				if [ $rc -ne 0 ]; then
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				fi
				image_directory="$working_directory/$(date +%s)"
				mkdir -p "$image_directory"
				echo "rm -r $image_directory" >>$tempfilelist
				progress 1 195
				extract_kernel "$download_directory/$firmwarestoragename" "$image_directory/$kernelfilename"
				rc=$?
				if [ $rc -ne 0 ]; then
					progress 3 97
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				else
					progress 3 96
					progress 1 63
					extract_filesystem "$download_directory/$firmwarestoragename" "$image_directory/$wrapperimagename"
					rc=$?
					if [ $rc -ne 0 ]; then
						progress 3 97
						echo -e "$(get_localized $lang $rc)" 1>&2
						exit $rc
					else
						progress 3 96
						progress 1 64
						extract_rootfs_from_wrapper "$image_directory/$wrapperimagename" "$image_directory/$rootfsname"
						rc=$?
						if [ $rc -ne 0 ]; then
							progress 3 97
							echo -e "$(get_localized $lang $rc)" 1>&2
							exit $rc
						else
							progress 3 96
							baseimage="$image_directory/$rootfsname"
							newkernelimage="$image_directory/$kernelfilename"
							wrapperimage="$image_directory/$wrapperimagename"
							progress 1 133
							remove_directory "$download_directory"
							progress 3 96
						fi
					fi
				fi
			fi
			debug "modfs: baseimage=$baseimage"
			debug "modfs: newkernelimage=$newkernelimage"
			debug "modfs: wrapperimage=$wrapperimage"
			debug "modfs: download_update selection done"
		fi
		;;
	file_update)
		if [ $update_file_provided -eq 0 ]; then
			baseimage="$(get_input_image_path)"
			rc=$?
			if [ $rc -gt 1 ]; then
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			fi
			# no file name selected means abort execution, an error message was already displayed
			[ ${#baseimage} -eq 0 ] && rc=1
			debug "modfs: file_update mode, file selection canceled"
		else	
			debug "modfs: firmware update file=$firmware_update_file"
			if ! [ -r "$firmware_update_file" ]; then
				progress 3 200 "$firmware_update_file"
				rc=200
			else
				firmware_update_file="$(realpath $firmware_update_file)"
				progress 3 199 "$firmware_update_file"
				rc=0
			fi
		fi
		if [ $rc -eq 0 ]; then
			working_directory="$(get_working_directory $extract_space_needed "tmpfs nand storage")"
			rc=$?
			if [ $rc -ne 0 ]; then
				echo -e "$(get_localized $lang $rc)" 1>&2
				debug "modfs: unable to get working directory"
				exit $rc
			fi
			debug "modfs: working directory=$working_directory"
			image_directory="$working_directory/$(date +%s)"
			mkdir -p "$image_directory"
			echo "rm -r $image_directory" >>$tempfilelist
			debug "modfs: image directory=$image_directory"
			progress 1 195
			extract_kernel "$firmware_update_file" "$image_directory/$kernelfilename"
			rc=$?
			if [ $rc -ne 0 ]; then
				progress 3 97
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			else
				progress 3 96
				progress 1 63
				extract_filesystem "$firmware_update_file" "$image_directory/$wrapperimagename"
				rc=$?
				if [ $rc -ne 0 ]; then
					progress 3 97
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				else
					progress 3 96
					progress 1 64
					extract_rootfs_from_wrapper "$image_directory/$wrapperimagename" "$image_directory/$rootfsname"
					rc=$?
					if [ $rc -ne 0 ]; then
						progress 3 97
						echo -e "$(get_localized $lang $rc)" 1>&2
						exit $rc
					else
						progress 3 96
						baseimage="$image_directory/$rootfsname"
						newkernelimage="$image_directory/$kernelfilename"
						wrapperimage="$image_directory/$wrapperimagename"
					fi
				fi
			fi
			debug "modfs: baseimage=$baseimage"
			debug "modfs: newkernelimage=$newkernelimage"
			debug "modfs: wrapperimage=$wrapperimage"
			debug "modfs: file_update selection done"
		fi
		;;
esac
if [ $rc -eq 0 ]; then
	debug "modfs: initialization done"
	# find a mountpoint with enough free storage for unpacking of squashfs
	# check current working directory (if any) first
	if [ ${#working_directory} -gt 0 ]; then
		path="$(echo "$working_directory" | check_space $free_space_for_unpack)"
		if [ ${#path} -gt 0 ]; then
			# current working directory seems to be suitable
			unpack_directory="$working_directory"
		fi
	else
		# no working directory selected yet
		unpack_directory=""
	fi
	if [ ${#unpack_directory} -eq 0 ]; then
		# we need (a new) working directory with enough free space
		unpack_directory="$(get_working_directory $free_space_for_unpack_tmpfs "tmpfs")"
		rc=$?
		if [ $rc -ne 0 ]; then
			# not enough space on tmpfs, try non-volatile storage now
			unpack_directory="$(get_working_directory $free_space_for_unpack "nand storage")"
			rc=$?
			if [ $rc -ne 0 ]; then
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			fi
		fi
	fi
	debug "modfs: unpack directory=$unpack_directory"
	if [ $rc -eq 0 ]; then
		if [ ${#unpack_directory} -eq 0 ]; then
			echo -e "$(get_localized $lang 58)" 1>&2
			rc=58
		fi
	fi
	if [ $rc -eq 0 ]; then
		# check file system at mount point - we need a native one
		fs="$(sed -n -e "s|^[^ \t]* $unpack_directory \(.*\) .* . .|\1|p" /proc/mounts)"
		if [ ${#fs} -eq 0 ]; then
			fs="$(sed -n -e "s|^[^ \t]* $(get_mountpoint $unpack_directory) \(.*\) .* . .|\1|p" /proc/mounts)"
		fi
		index_of_item $fs "$nativefilesystems" 1>/dev/null
		ind=$?
		if [ $ind -eq 1 ]; then
			debug "modfs: using loopback device with ext3 image for unpacking"
			# we'll use a loopback device to mount our ext3 image
			progress 1 140
			unpack_directory="$unpack_directory/$(date +%s)"
			mkdir -p "$unpack_directory"
			echo "rm -r $unpack_directory" >>$tempfilelist
			gunzip -c "$(filesdir)/$packedpartition" >"$unpack_directory/loopback"
			rc=$?
			if [ $rc -eq 0 ]; then
				progress 3 96
				progress 1 141
				loopback_host="$unpack_directory/loopback"
				tmp="$(get_temp_dir)"
				mount -o loop $loopback_host $tmp
				if [ $rc -eq 0 ]; then
					progress 3 96
					loopback_used=1
					unpack_directory="$tmp"
				else
					progress 3 97
					echo -e "$(get_localized $lang 55)" 1>&2
					rc=55
				fi
			else
				progress 3 97
				echo -e "$(get_localized $lang 54)" 1>&2
				rc=54
			fi
			debug "modfs: unpack directory=$unpack_directory"
		else
			debug "modfs: using a native filesystem for unpacking"
			loopback_used=0
			unpack_directory="$unpack_directory/$(date +%s)"
			mkdir -p $unpack_directory
			echo "rm -r $unpack_directory" >>$tempfilelist
		fi
	fi
fi
if [ $rc -eq 0 ]; then
	# unpack squashfs root image
	progress 1 144
	spinner "$tmpdirbase" unpack_squashfs "$baseimage" "$unpack_directory" 
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
		squashfs_blocksize=$(get_squashfs_blocksize $baseimage)
		squashfs_endianess=$(get_squashfs_endianess $baseimage)
		sq_version=$(get_squashfs_tools_version "$baseimage")
		echo -e "$(get_localized $lang 145 "$unpack_directory/$squashfsdirname")" 1>&2
	else
		progress 3 97
		if [ $rc -eq 38 ]; then
			echo -e "$(get_localized $lang $rc "$baseimage")" 1>&2
		else
			echo -e "$(get_localized $lang $rc)" 1>&2
		fi
	fi
	debug "modfs: unpacking SquashFS image done, rc=$rc"
fi
if [ $rc -eq 0 ]; then
	# modify root file system
	modify_rootfs "$unpack_directory/$squashfsdirname" "$scriptpath/modscripts"
	rc=$?
	if [ $rc -lt 2 ]; then
		rc=0
		echo -ne "$(get_localized $lang 150 $unpack_directory/$squashfsdirname)" 1>&2
		while [ 1 -eq 1 ]; do
			read abort
			if [ x$abort == xq ]; then
				echo -e "$(get_localized $lang 155)" 1>&2
				rc=1
				break
			else
				if [ ${#abort} -eq 0 ]; then
					echo -e "$msgtext_normal" 1>&2
					break
				fi
			fi
		done
	fi
	debug "modfs: modifications done, rc=$rc"
fi
if [ $rc -eq 0 ]; then
	# pack new root file system
	progress 1 146
	spinner "$unpack_directory" pack_squashfs "$unpack_directory" "$unpack_directory/newroot.squashfs" $squashfs_endianess $squashfs_blocksize $sq_version
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
	else
		progress 3 97
		echo -e "$(get_localized $lang $rc)" 1>&2
	fi
	debug "modfs: packing done, rc=$rc"
fi
if [ $rc -eq 0 -a $noversioncheck -eq 1 ]; then
	# update wrapper file system too, it should match the expected version for the new kernel
	progress 1 196
	copy_wrapper_filesystem "$wrapperimage" 
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
	else
		progress 3 97
		echo -e "$(get_localized $lang $rc)" 1>&2
	fi
	debug "modfs: update wrapper filesystem done, rc=$rc"
fi
if [ $rc -eq 0 ]; then
	# copy new root file system
	progress 1 147
	copy_new_root_filesystem "$unpack_directory/newroot.squashfs"
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
	else
		progress 3 97
		echo -e "$(get_localized $lang $rc)" 1>&2
	fi
	debug "modfs: copying new filesystem done, rc=$rc"
fi
if [ $rc -eq 0 -a $noversioncheck -eq 1 ]; then
	# update kernel partition too
	progress 1 198
	copy_kernel_image "$newkernelimage"
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
	else
		progress 3 97
		echo -e "$(get_localized $lang $rc)" 1>&2
	fi
	debug "modfs: update kernel done, rc=$rc"
fi
if [ $rc -eq 0 ]; then
	# switch system start partition
	progress 1 148
	switch_system_to alternative
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
		echo -e "$(get_localized $lang 149)" 1>&2
	else
		progress 3 97
		echo -e "$(get_localized $lang $rc)" 1>&2
	fi
	debug "modfs: switching system done, rc=$rc"
fi
if [ $loopback_used -eq 1 ]; then
	# unmount and remove loopback partition, if it was used
	progress 1 142
	umount "$unpack_directory"
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
		progress 1 143
		rm "$loopback_host" 2>/dev/null
		rc=$?
		lbdir="${loopback_host%/loopback}"
		[ x"$lbdir" != x"$loopback_host" ] && remove_directory "$lbdir"
		if [ $rc -eq 0 ]; then
			progress 3 96
		else
			progress 3 97
			echo -e "$(get_localized $lang 57)" 1>&2
			rc=57
		fi
	else
		echo -e "$(get_localized $lang 56)" 1>&2
		rc=56
		progress 3 97
	fi
	debug "modfs: unmounting loopback device done, rc=$rc"
	loopback_used=0
fi
#
# temporary directories to remove
#
remove_directory "$unpack_directory"
remove_directory "$image_directory"
#
# all done ... cleanup will take place here
#
debug "modfs: reached normal exit point, rc=$rc"
exit $rc
