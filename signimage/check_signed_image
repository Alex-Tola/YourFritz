#! /bin/sh
####################################################################################
#                                                                                  #
# check, if the specified image contains an AVM-like signature and if it is signed #
# with a key from the specified list of possible public key files (containing the  #
# public keys in AVM's format)                                                     #
#                                                                                  #
# The result of this check is written to STDERR and the return code is set to one  #
# of the values below:                                                             #
#                                                                                  #
#   0 - verification successful                                                    #
#   2 - missing arguments                                                          #
#   3 - specified image file not found                                             #
#   4 - the image file contains no "./var/signature" member                        #
#   5 - the signature file has a wrong size                                        #
#   6 - the specified list file does not exist                                     #
#   7 - no usable public key found                                                 #
#   8 - the signature file contains no ASN.1 structure                             #
#   9 - the signature file uses an unsupported hash algorithm                      #
#  10 - the hash algorithm used to sign isn't supported by the openssl binary      #
#  32 - "openssl" binary not found                                                 #
#  33 - "openssl" function "dgst" is not available                                 #
#  34 - "openssl" function "rsautl" is not available                               #
#  64 - signature verification failed                                              #
#                                                                                  #
####################################################################################
#                                                                                  #
# some subfunctions                                                                #
#                                                                                  #
####################################################################################
show_error() { echo -e "\x1B[1;31mFAILED\x1B[0m" 1>&2; }
show_ok() { echo -e "\x1B[1;32mOK\x1B[0m" 1>&2; }
show_version() 
{ 
	local v
	v=$(openssl version 2>/dev/null)
	if [ $? -eq 127 ]; then
		echo -e "Missing 'openssl' binary." 1>&2
		return 1
	else
		echo -e "Found \x1B[1;34m$v\x1B[0m" 1>&2
		return 0
	fi
}
####################################################################################
#                                                                                  #
# usage screen, caller has to redirect output to STDERR if needed                  #
#                                                                                  #
####################################################################################
usage()
{
	echo -e "\x1B[1mCheck, if the signature of the specified image file is valid.\x1B[0m\n"
	echo -e "Usage:\n"
	echo -e "$0 \x1B[1mimagefile\x1B[0m { -f \x1B[1mpubkey_list_file\x1B[0m | \x1B[1mpubkey_file\x1B[0m }\n"
	echo -e "\x1B[1mimagefile\x1B[0m is the archive to check and \x1B[1mpubkey_list_file\x1B[0m has"
	echo -e "to contain the name(s) of possible public key files, one name per line."
	echo -e "If you know the right public key for sure, you may specify its file name"
	echo -e "instead of using a list."
	echo -e ""
	echo -e "Remark:"
	echo -e "If you have an image file not signed by AVM, it may use better hash"
	echo -e "algorithms from a limited set (md5, sha1, sha224, sha256, sha512,"
	echo -e "whirlpool), as long as the openssl binary supports this algorithm."
	echo -e "The algorithm used to create the signature (by the signer) is detected"
	echo -e "while decoding the signature file in a first step (its format will be"
	echo -e "checked too in this step)."
}
####################################################################################
#                                                                                  #
# helper to convert from hexadecimal dumped modulus to DER format, look at         #
# avm_pubkey_to_pkcs8 for a version with comments                                  #
#                                                                                  #
####################################################################################
modulus_to_der()
{
	local mod="$1" exp="${2:-010001}"
	local type_int=02 type_seq=30 type_bstr=03 type_oid=06 type_null=0500

	hex_even()
	{
		local value=$1 len count rem
		len=$(printf %x $value)
		count=${#len}
		rem=$(( count % 2 ))
		[ $rem -ne 0 ] && len="0$len"
		echo $len
	}
	hex2bin()
	{
		local val="$1" out=""
		while [ ${#val} -gt 0 ]; do
			out="$out\x${val:0:2}"
			val="${val:2}"
		done
		printf "$out"
	}
	asn1_length()
	{
		local len=0 value=$1 res interm
		len=$(( ${#value} / 2 ))
		if [ $len -gt 127 ]; then
			interm=$(hex_even $len)
			len=$(( ( ${#interm} / 2 ) + 128 ))
			res=$(hex_even $len)$interm
		else
			res=$(hex_even $len)
		fi
		echo $res
	}

	m_len=$type_int$(asn1_length "$mod")
	e_len=$type_int$(asn1_length "$exp")
	pk_c=$m_len$mod$e_len$exp
	pk_len=$(asn1_length "$pk_c")
	pk_seq=$type_seq$pk_len$pk_c
	pk_bit=00$pk_seq
	bits=$type_bstr$(asn1_length "$pk_bit")$pk_bit
	oid=2A864886F70D010101
	o_enc=$type_oid$(asn1_length "$oid")$oid
	o_alg=$o_enc$type_null
	o_seq=$type_seq$(asn1_length "$o_alg")$o_alg
	der=$type_seq$(asn1_length "$o_seq$bits")
	hex2bin "$der$o_seq$bits"
}
####################################################################################
#                                                                                  #
# check image file                                                                 #
#                                                                                  #
####################################################################################
if [ -z $1 ]; then
		usage 1>&2
		exit 2
else
	image_file="$1"
fi
if ! [ -f "$image_file" ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m does not exist." 1>&2
	exit 3
fi
####################################################################################
#                                                                                  #
# check OpenSSL presence and version                                               #
#                                                                                  #
####################################################################################
show_version
[ $? -ne 0 ] && exit 32
echo -en "Check 'dgst' command ... " 1>&2
echo "" | openssl dgst 2>&1 | grep -q '^(stdin)=' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok 
else
	show_error
	exit 33
fi
echo -en "Check 'rsautl' command ... " 1>&2
echo "" | openssl rsautl 2>&1 | grep -q '^no keyfile specified' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok 
else
	show_error
	exit 34
fi
####################################################################################
#                                                                                  #
# prepare a temporary directory and cleanup on exit                                #
#                                                                                  #
####################################################################################
tmp=$(mktemp -d)
[ $? -eq 127 ] && tmp="/tmp/tmp.$(date +%s).$$" && mkdir -p "$tmp"
trap "rm -r \"$tmp\"" EXIT HUP
####################################################################################
#                                                                                  #
# If the signature isn't the last file (we've checked the length already), we have #
# to find the offset of the last member with the signature name - the last one is  #
# important, because the archive may contain more than one member with the same    #
# name and the last one will overwrite all previously extracted files ... we need  #
# more space at the filesystem, if we must create a "phantom file" to be used with #
# the digest computation.                                                          # 
# Here we could try to find the member name in the file content, but this would be #
# impossible with "normal" commands (I don't know any applet, which may find a     #
# string in a binary file and return the offsets of these strings) and searching   #
# a hexdump output is really boring and much too slow.                             #
# A better approach should be to count the archive members from start of file and  #
# to compute their respective offsets - we're interested in the last occurence of  #
# ./var/signature only.                                                            #
# We compute the offset and size of every member here, it makes things easier      #
# while checking the signature presence and format.                                #
#                                                                                  #
####################################################################################
offset=0
tar -t -v -f "$image_file" | 
sed -n -e "s|^[^ ]* *[^ ]* *\([0-9]*\) *[^ ]* *[^ ]* *\(.*\)\$|SIZE=\1 MEMBER=\2|p" |
while read line; do
	eval $line
	file_offset=$offset
	file_start=$(( file_offset + 512 ))
	file_end=$(( file_start + SIZE ))
	offset=$(( ( ( file_end + 511 ) / 512 ) * 512 ))
	echo "HEADER=$file_offset START=$file_start END=$file_end SIZE=$SIZE BLOCKS=$(( ( offset - file_offset ) / 512 )) MEMBER=\"$MEMBER\"" >>"$tmp/image_members"
done
####################################################################################
#                                                                                  #
# get the signature file from the image and check that it is in the expected       #
# format, before we waste a lot of time with checking an invalid signature file    #
#                                                                                  #
####################################################################################
last_sig=0
i=0
while read line; do
	i=$(( i + 1 ))
	eval $line
	if [ "$MEMBER" == "./var/signature" ]; then
		last_sig=$i
	fi
done <"$tmp/image_members"
if [ $last_sig -eq 0 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains no signature file." 1>&2
	exit 4
fi
eval "$(sed -n -e "${last_sig}p" "$tmp/image_members")"
if [ $SIZE -ne 128 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains an invalid signature file." 1>&2
	exit 5
fi
tar -x -f "$image_file" -C "$tmp" ./var/signature 2>/dev/null
if [ $(stat -c %s "$tmp/var/signature") -ne 128 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains an invalid signature file." 1>&2
	exit 5
fi
seek_image=$(( HEADER / 512 ))
skip_blocks=$BLOCKS
####################################################################################
#                                                                                  #
# check, if we have a single public key file or a list of possible candidates      #
#                                                                                  #
####################################################################################
if [ -z $2 ]; then
	usage 1>&2
	exit 2
fi
if [ "$2" == "-f" ]; then
	multiple_keys=1
	if [ -z "$3" ]; then
		usage 1>&2
		exit 2
	fi
	if ! [ -f "$3" ]; then
		echo -e "The specified public key list file \x1B[1m$3\x1B[0m does not exist." 1>&2
		exit 6
	fi
	while read filename; do
		if [ -f "$filename" ]; then
			mod=$(sed -n -e "1p" "$filename")
			exp=$(sed -n -e "2p" "$filename")
			[ ${#exp} -eq 0 ] && exp=010001
			echo "DESC=\"\" SRC=\"$filename\" MOD=$mod EXP=$exp" >>"$tmp/public_keys"
		fi
	done <"$3"
else
	multiple_keys=0
	mod=$(sed -n -e "1p" "$2")
	exp=$(sed -n -e "2p" "$2")
	[ ${#exp} -eq 0 ] && exp=010001
	echo "DESC=\"from command line\" SRC=\"$2\" MOD=$mod EXP=$exp" >>"$tmp/public_keys"
fi
####################################################################################
#                                                                                  #
# determine the used private key ... try to decode the signature file with every   #
# public key specified, until the usable was found or the end of list is reached   #
#                                                                                  #
####################################################################################
if [ $multiple_keys -eq 1 ]; then
	echo -e "Trying to determine the correct key ... " 1>&2
fi
key_found=0
valid_algo=0
algo=""
while read line; do
	eval $line
	echo -en "Checking the public key from \x1B[1m$SRC\x1B[0m ... " 1>&2
	modulus_to_der $MOD $EXP >"$tmp/pubkey.der"
	output="$(openssl rsautl -verify -pubin -inkey "$tmp/pubkey.der" -keyform der -asn1parse -in "$tmp/var/signature" 2>&1)"
	rc=$?
	if [ $rc -eq 0 ]; then
		key_found=1
		show_ok
		algo=$(echo "$output" | sed -n -e "s|^.*OBJECT.*:\(.*\)\$|\1|p" 2>/dev/null)
		if [ ${#algo} -gt 0 ]; then
			echo -en "Checking support for the used hash algorithm '$algo' ... " 1>&2
			valid_algo=0
			for a in md5 sha1 sha224 sha256 sha384 sha512 whirlpool; do
				if [ "$a" == "$algo" ]; then
					valid_algo=1
					break
				fi
			done
			if [ $valid_algo -eq 1 ]; then
				echo "" | openssl dgst -$algo 2>&1 2>/dev/null 1>&2
				rc=$?
				if [ $rc -eq 0 ]; then
					show_ok
				else
					show_error
					exit 10
				fi
			else
				show_error
				exit 9
			fi
		else
			show_error
			exit 8
		fi
	else
		show_error
	fi
done <"$tmp/public_keys"
if [ $key_found -eq 0 ]; then
	echo -e "No usable public key was found." 1>&2
	exit 7
fi
####################################################################################
#                                                                                  #
# now we check the signature with the openssl binary, we prepare the changed image #
# file in a subshell and pipe its output to openssl                                #
#                                                                                  #
####################################################################################
res="$( ( dd if="$image_file" bs=512 count=$seek_image status=none 2>/dev/null;
dd if=/dev/zero bs=512 count=2 status=none 2>/dev/null;
dd if="$image_file" bs=512 skip=$(( seek_image + 2 )) status=none 2>/dev/null ) |
openssl dgst -$algo -verify "$tmp/pubkey.der" -keyform der -signature "$tmp/var/signature")"
rc=$?
if [ $rc -ne 0 ]; then
	echo -e "Signature verification failed." 1>&2
	exit 64
fi
####################################################################################
#                                                                                  #
# all done                                                                         #
#                                                                                  #
####################################################################################
echo -e "Verification succeeded." 1>&2
exit 0
####################################################################################
#                                                                                  #
# end of file                                                                      #
#                                                                                  #
####################################################################################

