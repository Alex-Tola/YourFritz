#! /bin/sh
####################################################################################
#                                                                                  #
# check, if the specified image contains an AVM-like signature and if it is signed #
# with a key from the specified list of possible public key files (containing the  #
# public keys in AVM's format)                                                     #
#                                                                                  #
# The result of this check is written to STDERR and the return code is set to one  #
# of the values below:                                                             #
#                                                                                  #
#   0 - verification successful                                                    #
#   2 - missing arguments                                                          #
#   3 - specified image file not found                                             #
#   4 - the image file contains no "./var/signature" member                        #
#   5 - the signature file has a wrong size                                        #
#   6 - the specified list file does not exist                                     #
#   7 - no usable public key found                                                 #
#   8 - the signature file contains no MD5 hash                                    #
#  32 - "openssl" binary not found                                                 #
#  33 - "openssl" function "dgst" is not available                                 #
#  34 - "openssl" function "rsautl" is not available                               #
#  64 - signature verification failed                                              #
#                                                                                  #
####################################################################################
#                                                                                  #
# some subfunctions                                                                #
#                                                                                  #
####################################################################################
show_error() { echo -e "\x1B[1;31mFAILED\x1B[0m" 1>&2; }
show_ok() { echo -e "\x1B[1;32mOK\x1B[0m" 1>&2; }
show_version() 
{ 
	local v
	v=$(openssl version 2>/dev/null)
	if [ $? -eq 127 ]; then
		echo -e "Missing 'openssl' binary." 1>&2
		return 1
	else
		echo -e "Found \x1B[1;34m$v\x1B[0m" 1>&2
		return 0
	fi
}
####################################################################################
#                                                                                  #
# usage screen, caller has to redirect output to STDERR if needed                  #
#                                                                                  #
####################################################################################
usage()
{
	echo -e "\x1B[1mCheck, if the signature of the specified image file is valid.\x1B[0m\n"
	echo -e "Usage:\n"
	echo -e "$0 \x1B[1mimagefile\x1B[0m { -f \x1B[1mpubkey_list_file\x1B[0m | \x1B[1mpubkey_file\x1B[0m }\n"
	echo -e "\x1B[1mimagefile\x1B[0m is the archive to check and \x1B[1mpubkey_list_file\x1B[0m has"
	echo -e "to contain the name(s) of possible public key files, one name per line."
	echo -e "If you know the right public key for sure, you may specify its file name"
	echo -e "instead of using a list."
}
####################################################################################
#                                                                                  #
# check image file                                                                 #
#                                                                                  #
####################################################################################
if [ -z $1 ]; then
		usage 1>&2
		exit 2
else
	image_file="$1"
fi
if ! [ -f "$image_file" ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m does not exist." 1>&2
	exit 3
fi
####################################################################################
#                                                                                  #
# check OpenSSL presence and version                                               #
#                                                                                  #
####################################################################################
show_version
[ $? -ne 0 ] && exit 32
echo -en "Check 'dgst' command ... " 1>&2
echo "" | openssl dgst 2>&1 | grep -q '^(stdin)=' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok 
else
	show_error
	exit 33
fi
echo -en "Check 'rsautl' command ... " 1>&2
echo "" | openssl rsautl 2>&1 | grep -q '^no keyfile specified' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok 
else
	show_error
	exit 34
fi
####################################################################################
#                                                                                  #
# prepare a temporary directory and cleanup on exit                                #
#                                                                                  #
####################################################################################
tmp=$(mktemp -d)
[ $? -eq 127 ] && tmp="/tmp/tmp.$(date +%s).$$" && mkdir -p "$tmp"
trap "rm -r \"$tmp\"" EXIT HUP
####################################################################################
#                                                                                  #
# If the signature isn't the last file (we've checked the length already), we have #
# to find the offset of the last member with the signature name - the last one is  #
# important, because the archive may contain more than one member with the same    #
# name and the last one will overwrite all previously extracted files ... we need  #
# more space at the filesystem, if we must create a "phantom file" to be used with #
# the digest computation.                                                          # 
# Here we could try to find the member name in the file content, but this would be #
# impossible with "normal" commands (I don't know any applet, which may find a     #
# string in a binary file and return the offsets of these strings) and searching   #
# a hexdump output is really boring and much too slow.                             #
# A better approach should be to count the archive members from start of file and  #
# to compute their respective offsets - we're interested in the last occurence of  #
# ./var/signature only.                                                            #
# We compute the offset and size of every member here, it makes things easier      #
# while checking the signature presence and format.                                #
#                                                                                  #
####################################################################################
offset=0
tar -t -v -f "$image_file" | 
sed -n -e "s|^[^ ]* *[^ ]* *\([0-9]*\) *[^ ]* *[^ ]* *\(.*\)\$|SIZE=\1 MEMBER=\2|p" |
while read line; do
	eval $line
	file_offset=$offset
	file_start=$(( file_offset + 512 ))
	file_end=$(( file_start + SIZE ))
	offset=$(( ( ( file_end + 511 ) / 512 ) * 512 ))
	echo "HEADER=$file_offset START=$file_start END=$file_end SIZE=$SIZE BLOCKS=$(( ( offset - file_offset ) / 512 )) MEMBER=\"$MEMBER\"" >>"$tmp/image_members"
done
####################################################################################
#                                                                                  #
# get the signature file from the image and check that it is in the expected       #
# format, before we waste a lot of time with checking an invalid signature file    #
#                                                                                  #
####################################################################################
last_sig=0
i=0
while read line; do
	i=$(( i + 1 ))
	eval $line
	if [ "$MEMBER" == "./var/signature" ]; then
		last_sig=$i
	fi
done <"$tmp/image_members"
if [ $last_sig -eq 0 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains no signature file." 1>&2
	exit 4
fi
eval "$(sed -n -e "${last_sig}p" "$tmp/image_members")"
if [ $SIZE -ne 128 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains an invalid signature file." 1>&2
	exit 5
fi
tar -x -f "$image_file" -C "$tmp" ./var/signature 2>/dev/null
if [ $(stat -c %s "$tmp/var/signature") -ne 128 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains an invalid signature file." 1>&2
	exit 5
fi
seek_image=$(( HEADER / 512 ))
skip_blocks=$BLOCKS
####################################################################################
#                                                                                  #
# check, if we have a single public key file or a list of possible candidates      #
#                                                                                  #
####################################################################################
if [ -z $2 ]; then
	usage 1>&2
	exit 2
fi
if [ "$2" == "-f" ]; then
	multiple_keys=1
	if [ -z "$3" ]; then
		usage 1>&2
		exit 2
	fi
	if ! [ -f "$3" ]; then
		echo -e "The specified public key list file \x1B[1m$3\x1B[0m does not exist." 1>&2
		exit 6
	fi
	cat "$3" >"$tmp/public_keys"
else
	multiple_keys=0
	echo "$2" >"$tmp/public_keys"
fi
####################################################################################
#                                                                                  #
# determine the used private key ... try to decode the signature file with every   #
# public key specified, until the usable was found or the end of list is reached   #
#                                                                                  #
####################################################################################
if [ $multiple_keys -eq 1 ]; then
	echo -e "Trying to determine the correct key ... " 1>&2
fi
key_found=0
for k in $(cat "$tmp/public_keys"); do
	echo -en "Checking the public key from \x1B[1m$k\x1B[0m ... " 1>&2
	avm_pubkey_to_pkcs8 <"$k" >"$tmp/pubkey.pem"
	output="$(openssl rsautl -verify -pubin -inkey "$tmp/pubkey.pem" -asn1parse -in "$tmp/var/signature" 2>&1)"
	rc=$?
	if [ $rc -eq 0 ]; then
		echo "$output" | grep -q "OBJECT.*:md5" 2>/dev/null
		if [ $? -eq 0 ]; then
			show_ok
			key_found=1
			break
		else
			show_error
			exit 8
		fi
	else
		show_error
	fi
done
if [ $key_found -eq 0 ]; then
	echo -e "No usable public key was found." 1>&2
	exit 7
fi
####################################################################################
#                                                                                  #
# now we check the signature with the openssl binary, we prepare the changed image #
# file in a subshell and pipe its output to openssl                                #
#                                                                                  #
####################################################################################
res="$( ( dd if="$image_file" bs=512 count=$seek_image status=none 2>/dev/null;
dd if=/dev/zero bs=512 count=2 status=none 2>/dev/null;
dd if="$image_file" bs=512 skip=$(( seek_image + 2 )) status=none 2>/dev/null ) |
openssl dgst -md5 -verify "$tmp/pubkey.pem" -signature "$tmp/var/signature")"
rc=$?
if [ $rc -ne 0 ]; then
	echo -e "Signature verification failed." 1>&2
	exit 64
fi
####################################################################################
#                                                                                  #
# all done                                                                         #
#                                                                                  #
####################################################################################
echo -e "Verification succeeded." 1>&2
exit 0
####################################################################################
#                                                                                  #
# end of file                                                                      #
#                                                                                  #
####################################################################################

