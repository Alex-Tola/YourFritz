#! /bin/sh
####################################################################################
#                                                                                  #
# check, if the specified image contains an AVM-like signature and if it is signed #
# with a key from the specified list of possible public key files (containing the  #
# public keys in AVM's format)                                                     #
#                                                                                  #
# The result of this check is written to STDERR and the return code is set to one  #
# of the values below:                                                             #
#                                                                                  #
#   0 - verification successful                                                    #
#   2 - missing arguments                                                          #
#   3 - specified image file not found                                             #
#   4 - the image file contains no "./var/signature" member                        #
#   5 - the signature file has a wrong size                                        #
#   6 - the specified list file does not exist                                     #
#   7 - no usable public key found                                                 #
#   8 - the signature file contains no ASN.1 structure                             #
#   9 - the signature file uses an unsupported hash algorithm                      #
#  10 - the hash algorithm used to sign isn't supported by the openssl binary      #
#  11 - none of the specified public key sources was able to provide a key         #
#  32 - "openssl" binary not found                                                 #
#  33 - "openssl" function "dgst" is not available                                 #
#  34 - "openssl" function "rsautl" is not available                               #
#  64 - signature verification failed                                              #
#                                                                                  #
####################################################################################
#                                                                                  #
# some subfunctions                                                                #
#                                                                                  #
####################################################################################
show_error() { echo -e "\x1B[1;31mFAILED\x1B[0m" 1>&2; }
show_ok() { echo -e "\x1B[1;32mOK\x1B[0m" 1>&2; }
show_version() 
{ 
	local v
	v=$(openssl version 2>/dev/null)
	if [ $? -eq 127 ]; then
		echo -e "Missing 'openssl' binary." 1>&2
		return 1
	else
		echo -e "Found \x1B[1;34m$v\x1B[0m" 1>&2
		return 0
	fi
}
####################################################################################
#                                                                                  #
# usage screen, caller has to redirect output to STDERR if needed                  #
#                                                                                  #
####################################################################################
usage()
{
	echo -e "\x1B[1mCheck, if the signature of the specified image file is valid.\x1B[0m\n"
	echo -e "Usage:\n"
	echo -e "$0 \x1B[1mimagefile\x1B[0m \x1B[1mpublickey_source\x1B[0m [...]\n"
	echo -e "\x1B[1mimagefile\x1B[0m is the archive to check and the list of public keys to consider"
	echo -e "for decryption may be built from the following sources:"
	echo -e ""
	echo -e "-f \x1B[1mfilename\x1B[0m - add the file names in the specified file"
	echo -e "-b          - add AVM default keys (avm_firmware_public_key[1-3] and"
	echo -e "              plugin_global_key.pem) to considerations"
	echo -e "\x1B[1mfilename\x1B[0m    - add the specified file to the list"
	echo -e ""
	echo -e "The first key from the specified sources (which are probed in the"
	echo -e "given order) able to decode the signature file will be used for"
	echo -e "signature verification."
	echo -e ""
	echo -e "Remark:"
	echo -e "If you have an image file not signed by AVM, it may use better hash"
	echo -e "algorithms from a limited set (md5, sha1, sha224, sha256, sha512,"
	echo -e "whirlpool), as long as the openssl binary supports this algorithm."
	echo -e "The algorithm used to create the signature (by the signer) is detected"
	echo -e "while decoding the signature file in a first step (its format will be"
	echo -e "checked too in this step)."
}
####################################################################################
#                                                                                  #
# output the lines to use the builtin keys from AVM images - taken from the files  #
# /etc/avm_firmware_public_keys[1-3] and in /etc/plugin_global_key.pem in current  #
# firmware for the 7390 model (84.06.51)                                           #
#                                                                                  #
####################################################################################
builtin_keys()
{
	local avm1="DESC=\"AVM default key 1\" SRC=\"avm_firmware_public_key1\" MOD=\"\
00ab54b73f000e9fc5bf3c0d229e56ae1644507877ca1eaf364708975de1e50236754fdc8577bd9e9e\
c4c94bd595c22195a9cfa2ac57840c507b483ccf1c5d4d1448c6d8c8bdab629df4e5bcd65a52695064\
819d1f5157afeb8fea43dedd9c7b091c344cfb42434f5f7bc77bbf2c0469400d10a29d04d6c1b2807f\
d3be68800eaf\" EXP=\"010001\""
	local avm2="DESC=\"AVM default key 2\" SRC=\"avm_firmware_public_key2\" MOD=\"\
00c923d6cde5ca1780e84b6383c6c24b03a56532149f0a210541f16b1698d5761dd90ffd77500ff5dd\
2c9269710dad5ebcb1f6fbf318993429fcb228c043cc0980ec09b85b8a393c96b3e52f647b898ddff3\
7aa9f662771aa87cee8686d3e2e3970a38e25bdc13f591344a2f6a39647a6555696fca21423e90c987\
e990ad64ff81\" EXP=\"010001\""
	local avm3="DESC=\"AVM default key 3\" SRC=\"avm_firmware_public_key3\" MOD=\"\
00f2ee9ffd8556211f5644da48a252b107124b330d4c20dcf3b9bac892924cabaa4df4f53e1c62e3f2\
aa12a23eb1d770df1520a998078738407e6a71b077f73ba976363836b880b0dd88741bc3b83ab06169\
1226e823404b7fc88ed278d8130fe5336eb925c78f2f8ad7cb87d9586286f768ab3236fa8fb51ae7c4\
bbe1e041d849\" EXP=\"010001\""
	local plugin="DESC=\"AVM plugin key\" SRC=\"plugin_global_key.pem\"     MOD=\"\
00bed5268d38b33fe9876f4ae22a5970657c3501adcb84879654def6fc83c1303667b12a031025782c\
b6490fed946ec81c3968ebc5d50697af9a2475339692eb5c84240cac09b2b3ca2a419efb6ae206e782\
209fc5a405054630634d4a4bb0f3c053c72547f2fb95add232929a7f722db94d873e02cbb2985106d6\
dd66dfa5592f\" EXP=\"010001\""
	echo "$avm1"
	echo "$avm2"
	echo "$avm3"
	echo "$plugin"
}
####################################################################################
#                                                                                  #
# helper to convert from hexadecimal dumped modulus to DER format, look at         #
# avm_pubkey_to_pkcs8 for a version with comments                                  #
#                                                                                  #
####################################################################################
modulus_to_der()
{
	local mod="$1" exp="${2:-010001}"
	local type_int=02 type_seq=30 type_bstr=03 type_oid=06 type_null=0500

	hex_even()
	{
		local value=$1 len count rem
		len=$(printf %x $value)
		count=${#len}
		rem=$(( count % 2 ))
		[ $rem -ne 0 ] && len="0$len"
		echo $len
	}
	hex2bin()
	{
		local val="$1" out=""
		while [ ${#val} -gt 0 ]; do
			out="$out\x${val:0:2}"
			val="${val:2}"
		done
		printf "$out"
	}
	asn1_length()
	{
		local len=0 value=$1 res interm
		len=$(( ${#value} / 2 ))
		if [ $len -gt 127 ]; then
			interm=$(hex_even $len)
			len=$(( ( ${#interm} / 2 ) + 128 ))
			res=$(hex_even $len)$interm
		else
			res=$(hex_even $len)
		fi
		echo $res
	}

	m_len=$type_int$(asn1_length "$mod")
	e_len=$type_int$(asn1_length "$exp")
	pk_c=$m_len$mod$e_len$exp
	pk_len=$(asn1_length "$pk_c")
	pk_seq=$type_seq$pk_len$pk_c
	pk_bit=00$pk_seq
	bits=$type_bstr$(asn1_length "$pk_bit")$pk_bit
	oid=2A864886F70D010101
	o_enc=$type_oid$(asn1_length "$oid")$oid
	o_alg=$o_enc$type_null
	o_seq=$type_seq$(asn1_length "$o_alg")$o_alg
	der=$type_seq$(asn1_length "$o_seq$bits")
	hex2bin "$der$o_seq$bits"
}
####################################################################################
#                                                                                  #
# check image file                                                                 #
#                                                                                  #
####################################################################################
if [ -z $1 ]; then
		usage 1>&2
		exit 2
else
	image_file="$1"
fi
if ! [ -f "$image_file" ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m does not exist." 1>&2
	exit 3
fi
####################################################################################
#                                                                                  #
# check OpenSSL presence and version                                               #
#                                                                                  #
####################################################################################
show_version
[ $? -ne 0 ] && exit 32
echo -en "Check 'dgst' command ... " 1>&2
echo "" | openssl dgst 2>&1 | grep -q '^(stdin)=' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok 
else
	show_error
	exit 33
fi
echo -en "Check 'rsautl' command ... " 1>&2
echo "" | openssl rsautl 2>&1 | grep -q '^no keyfile specified' 2>/dev/null 1>&2
rc=$?
if [ $rc -eq 0 ]; then
	show_ok 
else
	show_error
	exit 34
fi
####################################################################################
#                                                                                  #
# prepare a temporary directory and cleanup on exit                                #
#                                                                                  #
####################################################################################
tmp=$(mktemp -d)
[ $? -eq 127 ] && tmp="/tmp/tmp.$(date +%s).$$" && mkdir -p "$tmp"
trap "rm -r \"$tmp\"" EXIT HUP
####################################################################################
#                                                                                  #
# If the signature isn't the last file (we've checked the length already), we have #
# to find the offset of the last member with the signature name - the last one is  #
# important, because the archive may contain more than one member with the same    #
# name and the last one will overwrite all previously extracted files ... we need  #
# more space at the filesystem, if we must create a "phantom file" to be used with #
# the digest computation.                                                          # 
# Here we could try to find the member name in the file content, but this would be #
# impossible with "normal" commands (I don't know any applet, which may find a     #
# string in a binary file and return the offsets of these strings) and searching   #
# a hexdump output is really boring and much too slow.                             #
# A better approach should be to count the archive members from start of file and  #
# to compute their respective offsets - we're interested in the last occurence of  #
# ./var/signature only.                                                            #
# We compute the offset and size of every member here, it makes things easier      #
# while checking the signature presence and format.                                #
#                                                                                  #
####################################################################################
offset=0
tar -t -v -f "$image_file" | 
sed -n -e "s|^[^ ]* *[^ ]* *\([0-9]*\) *[^ ]* *[^ ]* *\(.*\)\$|SIZE=\1 MEMBER=\2|p" |
while read line; do
	eval $line
	file_offset=$offset
	file_start=$(( file_offset + 512 ))
	file_end=$(( file_start + SIZE ))
	offset=$(( ( ( file_end + 511 ) / 512 ) * 512 ))
	echo "HEADER=$file_offset START=$file_start END=$file_end SIZE=$SIZE BLOCKS=$(( ( offset - file_offset ) / 512 )) MEMBER=\"$MEMBER\"" >>"$tmp/image_members"
done
####################################################################################
#                                                                                  #
# get the signature file from the image and check that it is in the expected       #
# format, before we waste a lot of time with checking an invalid signature file    #
#                                                                                  #
####################################################################################
last_sig=0
i=0
while read line; do
	i=$(( i + 1 ))
	eval $line
	if [ "$MEMBER" == "./var/signature" ]; then
		last_sig=$i
	fi
done <"$tmp/image_members"
if [ $last_sig -eq 0 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains no signature file." 1>&2
	exit 4
fi
eval "$(sed -n -e "${last_sig}p" "$tmp/image_members")"
if [ $SIZE -ne 128 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains an invalid signature file." 1>&2
	exit 5
fi
tar -x -f "$image_file" -C "$tmp" ./var/signature 2>/dev/null
if [ $(stat -c %s "$tmp/var/signature") -ne 128 ]; then
	echo -e "The specified image file \x1B[1m$image_file\x1B[0m contains an invalid signature file." 1>&2
	exit 5
fi
seek_image=$(( HEADER / 512 ))
skip_blocks=$BLOCKS
####################################################################################
#                                                                                  #
# copy the specified public keys from different sources to our temporary key list  #
#                                                                                  #
####################################################################################
touch "$tmp/public_keys"
shift
if [ -z $1 ]; then
	usage 1>&2
	exit 2
fi
while [ "$#" -gt 0 ]; do
	case "$1" in
		"-f")
			if [ -z "$2" ]; then
				echo "Missing filename after -f option." 1>&2
				exit 2
			fi
			if ! [ -f "$2" ]; then
				echo -e "The specified public key list file \x1B[1m$2\x1B[0m does not exist." 1>&2
				exit 6
			fi
			while read filename; do
				if [ -f "$filename" ]; then
					mod=$(sed -n -e "1p" "$filename")
					exp=$(sed -n -e "2p" "$filename")
					[ ${#exp} -eq 0 ] && exp=010001
					echo "DESC=\"\" SRC=\"$filename\" MOD=$mod EXP=$exp" >>"$tmp/public_keys"
				fi
			done <"$2"
			shift 2
			;;
		"-b")
			builtin_keys >>"$tmp/public_keys"
			shift
			;;	
		*)
			mod=$(sed -n -e "1p" "$1")
			exp=$(sed -n -e "2p" "$1")
			if [ ${#mod} -gt 0 ]; then
				[ ${#exp} -eq 0 ] && exp=010001
				echo "DESC=\"command line\" SRC=\"$1\" MOD=$mod EXP=$exp" >>"$tmp/public_keys"
			fi
			shift
			;;
	esac
done
if ! [ -s "$tmp/public_keys" ]; then
	echo "None of the specified public key files could be loaded." 1>&2
	exit 11
fi
####################################################################################
#                                                                                  #
# determine the used private key ... try to decode the signature file with every   #
# public key specified, until the usable was found or the end of list is reached   #
#                                                                                  #
####################################################################################
if [ $(sed -n -e "\$=" "$tmp/public_keys") -gt 1 ]; then
	echo -e "Trying to determine the correct key now ..." 1>&2
fi
key_found=0
valid_algo=0
algo=""
while read line; do
	eval $line
	echo -en "Checking the public key from \x1B[1m$SRC\x1B[0m ... " 1>&2
	modulus_to_der $MOD $EXP >"$tmp/pubkey.der"
	output="$(openssl rsautl -verify -pubin -inkey "$tmp/pubkey.der" -keyform der -asn1parse -in "$tmp/var/signature" 2>&1)"
	rc=$?
	if [ $rc -eq 0 ]; then
		key_found=1
		show_ok
		algo=$(echo "$output" | sed -n -e "s|^.*OBJECT.*:\(.*\)\$|\1|p" 2>/dev/null)
		if [ ${#algo} -gt 0 ]; then
			echo -en "Checking support for the used hash algorithm '$algo' ... " 1>&2
			valid_algo=0
			for a in md5 sha1 sha224 sha256 sha384 sha512 whirlpool; do
				if [ "$a" == "$algo" ]; then
					valid_algo=1
					break
				fi
			done
			if [ $valid_algo -eq 1 ]; then
				echo "" | openssl dgst -$algo 2>&1 2>/dev/null 1>&2
				rc=$?
				if [ $rc -eq 0 ]; then
					show_ok
					break
				else
					show_error
					exit 10
				fi
			else
				show_error
				exit 9
			fi
		else
			show_error
			exit 8
		fi
	else
		show_error
	fi
done <"$tmp/public_keys"
if [ $key_found -eq 0 ]; then
	echo -e "No usable public key was found." 1>&2
	exit 7
fi
####################################################################################
#                                                                                  #
# now we check the signature with the openssl binary, we prepare the changed image #
# file in a subshell and pipe its output to openssl                                #
#                                                                                  #
####################################################################################
res="$( ( dd if="$image_file" bs=512 count=$seek_image status=none 2>/dev/null;
dd if=/dev/zero bs=512 count=2 status=none 2>/dev/null;
dd if="$image_file" bs=512 skip=$(( seek_image + 2 )) status=none 2>/dev/null ) |
openssl dgst -$algo -verify "$tmp/pubkey.der" -keyform der -signature "$tmp/var/signature")"
rc=$?
if [ $rc -ne 0 ]; then
	echo -e "Signature verification failed." 1>&2
	exit 64
fi
####################################################################################
#                                                                                  #
# all done                                                                         #
#                                                                                  #
####################################################################################
echo -e "Verification succeeded." 1>&2
exit 0
####################################################################################
#                                                                                  #
# end of file                                                                      #
#                                                                                  #
####################################################################################

