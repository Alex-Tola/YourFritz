#######################################################################################
#
# summarize some often needed helper (shell) functions, which provide replacements
# of missing features in the very limited environment of FRITZ!OS with only a small
# selection of busybox applets and without many "generally available" commands like 
# "awk" or "od" and so on ...
#
# Surely some functions may be implemented in a more effective manner ... but the
# purpose of this file is to provide a very basic implementation of such functions
# with as few dependencies as possible and the normal shell in a busybox-based
# environment is "ash", which has limited capabilities too.
#
# Copyright (C) 2014-2016 P.HÃ¤mmerlein (http://www.yourfritz.de)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License under
# http://www.gnu.org/licenses/gpl-2.0.html
# for more details.
#
#######################################################################################
#
# endianess - detect the endianess of the system we're running on
#
# - this will "abuse" the routing table via /proc/net/route to find a network
#   mask which doesn't contain all ones or all zeros and the value of the most
#   left bit will be used to determine the endianess
# - if the "Mask" column cannot be found, "B" (big endian) is assumed, because
#   the main purpose of this script is the usage on a FRITZ!Box device and all
#   newer devices use big endian scheme to store data
#
# parameters:
#   none
#
# stdout:
#   "B" for big endian system and "L" for little endian system
#
# return code:
#   always 0 (no errors, default output of "B" in case of problems)
#
#######################################################################################
yf_endianess()
{
	local col endian="B" mask i=0
	col=$(sed -n -e "1s/\t/\n/pg" /proc/net/route | sed -e "/^[ \t]*\$/d" | grep -n "Mask" | sed -n -e "s/\([0-9]*\):Mask/\1/p")
	if [ ${#col} -gt 0 ]; then
		while [ $i -lt $col ]; do
			mask="$mask\([^ \t]*\)[ \t]*"
			i=$(( i + 1 ))
		done
		mask=$(sed -e "1d" /proc/net/route | sed -n -e "s|$mask.*|\\$col|p" | sed -e "/^FFFFFFFF\$/d" -e "/^00000000\$/d" | sed -n -e "1p")
		if [ ${#mask} -gt 0 ]; then
			mask=${mask:0:1}
			mask=${mask//[89A-F]/}
			[ ${#mask} -gt 0 ] && endian="L" || endian="B"
		fi
	fi
	echo $endian
	return 0
}
#######################################################################################
#
# is_decimal - check, if input string contains only decimal digits
#
# parameters:
#   $1 - input string
#
# return code:
#   0 - only digits found
#   1 - non-digit characters present
#
#######################################################################################
yf_is_decimal()
{
	local in="${1//[0-9]/}"
	[ ${#in} -gt 0 ] && return 1
	return 0
}
#######################################################################################
#
# is_hexadecimal - check, if input string contains only hexadecimal digits
#
# parameters:
#   $1 - input string
#
# return code:
#   0 - only valid digits found
#   1 - non-digit characters present
#
#######################################################################################
yf_is_hexadecimal()
{
	local in="${1//[0-9a-fA-F]/}"
	[ ${#in} -gt 0 ] && return 1
	return 0
}
#######################################################################################
#
# reverse_hex - reverse a hexadecimal string byte-wise
#
# parameters:
#   $1 - input string
#
# stdout:
#   input string in reverse order, swapped in two-character slices
#
# return code:
#   always 0
#
#######################################################################################
yf_reverse_hex()
{
	local in="$1" out
	while [ ${#in} -gt 0 ]; do
		out="${in:0:2}$out"
		in="${in:2}"
	done
	echo "$out"
	return 0
}
#######################################################################################
#
# word_of - return the n-th entry from a list of words
#
# parameters:
#   $1 - number of word to retrieve
#   $2 - word list 
#
# stdout:
#   the n-th word
#
# return code:
#   0 - value found
#   1 - invalid parameter ($1 isn't a decimal number or 0)
#   2 - word list is too short to find the n-th entry
#
#######################################################################################
yf_word_of()
{
	local n=$1 i=0 word
	yf_is_decimal $n
	[ $? -ne 0 ] && return 1
	[ $n -lt 1 ] && return 1
	for word in $2; do
		i=$(( i + 1 ))
		[ $i -eq $n ] && echo "$word" && return 0
	done
	return 2
}
#######################################################################################
#
# index_of - return the index of the specified word in the specified list
#
# parameters:
#   $1 - word to find
#   $2 - word list 
#
# stdout:
#   the index of the word in the list
#
# return code:
#   0 - value found
#   1 - word not found in list
#
#######################################################################################
yf_index_of()
{
	local needle="$1" haystack="$2" word i=0
	for word in $haystack; do
		i=$(( i + 1 ))
		[ $word == $needle ] && echo $i && return 0
	done
	return 1
}
#######################################################################################
#
# dec2hex - convert decimal value to hexadecimal string of the specified length
#           (two characters per byte)
#
# parameters:
#   $1 - input value (string representing a decimal)
#   $2 - length (in bytes) to be used for the output (the resulting string will use
#        this value * 2, because each output byte consists of two nibbles); if this
#        parameter is not specified, the needed length is determined by the value
#
# stdout:
#   input value converted to hexadecimal string, padded to the specified length if
#   necessary
#
# return code:
#   0 - stdout content is valid
#   1 - error occured (e.g. invalid parameter values)
#
#######################################################################################
yf_dec2hex()
{
	local val="$1" len="$2" chk mask="%x"
	chk="${val//[0-9]/}"
	[ ${#val} -eq 0 ] && return 1
	[ ${#chk} -gt 0 ] && return 1
	if [ -z $len ]; then
		chk=$(printf "$mask" $val)
		len=$(( ( ${#chk} + 1 ) / 2 ))
	else	
		chk="${len//[0-9]/}"
		[ ${#chk} -gt 0 ] && return 1
	fi
	len=$(( len << 1 ))
	mask="%0${len}x"
	printf "$mask" $val
	return 0
}
#######################################################################################
#
# hex2dec - convert hexadecimal string to decimal value
#
# parameters:
#   $1 - input value representing a hexadecimal string
#
# stdout:
#   input value converted to decimal value
#
# return code:
#   0 - stdout content is valid
#   1 - error occured (e.g. input format is invalid)
#
#######################################################################################
yf_hex2dec()
{
	local val="$1" out=0 chk
	chk="${val//[0-9a-fA-F]/}"
	[ ${#chk} -gt 0 ] && return 1
	[ $(( ${#val} % 2 )) -ne 0 ] && return 1
	while [ ${#val} -gt 0 ]; do
		eval out=$(( ( out << 8 ) + 0x${val:0:2} ))
		val="${val:2}"
	done
	printf "%lu" "$out"
	return 0
}
#######################################################################################
#
# hex2bin - convert hexadecimal string to binary data
#
# parameters:
#   $1 - input value representing a hexadecimal string
#
# stdout:
#   input value converted to binary content
#
# return code:
#   0 - stdout content is valid
#   1 - error occured (e.g. input format is invalid)
#
#######################################################################################
yf_hex2bin()
{
	local val="$1" out chk
	chk="${val//[0-9a-fA-F]/}"
	[ ${#chk} -gt 0 ] && return 1
	[ $(( ${#val} % 2 )) -ne 0 ] && return 1
	while [ ${#val} -gt 0 ]; do
		out="${out}\x${val:0:2}"
		val="${val:2}"
	done
	printf "$out"
	return 0
}
#######################################################################################
#
# str2hex - convert a string to its hexadecimal representation
#
# parameters:
#   $1 - input string
#
# stdout:
#   input string converted to its hexadecimal content (one character per nibble)
#
# return code:
#   always 0 - no errors possible
#
#######################################################################################
yf_str2hex()
{
	local i=0
	while [ ${#1} -gt $i ]; do
		printf "%02x" \'${1:$i:1}
		i=$(( i + 1 ))
	done	
	return 0
}
#######################################################################################
#
# bin2hex - convert binary data its hexadecimal representation (via base64 utility)
#
# parameters:
#   none
#
# stdio:
#   binary data to encode
#
# stdout:
#   input data converted to its hexadecimal format (one character per nibble) as string
#
# return code:
#   always 0 - no errors possible, empty input results in empty output
#
# remarks:
#   - this version can handle whitespace, newline and NUL characters too
#   - it needs the "base64" utility to encode the binary data to base64 and the output
#     of this applet is translated to hexadecimal in the next step
#   - this "double conversion" is time-consuming and you should use yf_str2hex as often
#     as possible
#
#######################################################################################
yf_bin2hex()
{
	local in i=0 f=0 v=0 l=0
	in=$(base64 2>/dev/null | sed -e ':x;$!N;s/\n//;tx' -e 's/+/_/g')
	[ ${#in} -eq 0 ] && return
	while [ ${#in} -gt $i ]; do
		[ ${in:$i:1} == = ] && let f+=1 || \
			v=$(( ( v << 6 ) + $(( $(expr index "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_/" "${in:$i:1}") - 1 )) ))
		let l+=1
		if [ $l -eq 4 ]; then
			v=$(( v >> ( f * 2 ) ))
			printf "%0$(( ( 3 - f ) << 1 ))x" $v
			l=0
			v=0
		fi
		let i+=1
	done
	return 0
}
#######################################################################################
#
# ipv4addr - convert an IPv4 address from dotted-decimal format to hexadecimal
#            string in "network order" (big endian)
#
# parameters:
#   $1 - string representing the IPv4 address, may be any valid decimal value (within
#        the range of validity) or a dotted-decimal of up to four parts 
#
# stdout:
#   hexadecimal string representing the IP address in big endian order (MSB)
#
# return code:
#   0 - stdout value is valid
#   1 - error occured, the specified parameter isn't a valid IPv4 address
#
# remarks:
# The range check is performed with the final value, there may be an overflow earlier,
# if the input string is very "malformed".
#
#######################################################################################
yf_ipv4addr()
{
	local in="$1" addr=0 orgifs="$IFS" shifts=4 error=0
	IFS=. 
	set -- $in
	IFS="$orgifs"
	while [ ${#1} -gt 0 ]; do
		tupel=$1
		shift
		chk=${tupel//[0-9]/}
		if [ ${#chk} -gt 0 ]; then
			error=1
			break
		fi
		if [ ${#1} -gt 0 ]; then
			if [ $tupel -gt 255 ]; then
				error=1
				break
			fi
			addr=$(( ( addr << 8 ) + tupel ))
			shifts=$(( shifts - 1 ))
		else
			addr=$(( ( addr << ( shifts * 8 ) ) + tupel ))
		fi
	done
	if [ $addr -lt $(( 0x01000000 )) -o $addr -gt $(( 0xFFFFFFFF )) ]; then
		addr=0
		error=1
	fi
	yf_dec2hex $addr
	return $error
}
#######################################################################################
#
# uppercase - convert string to uppercase letters
#
# parameters:
#   none
#
# stdin:
#   input data to be translated ... only ASCII characters are handled correctly
#
# stdout:
#   input data with each occurence of 'a' to 'z' translated to 'A' to 'Z'
#
# return code:
#   0 - stdout value is valid
#   1 - error occured, usally stdin isn't a valid stream or 'tr' finished with errors
#
#######################################################################################
yf_uppercase()
{
	tr "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz"
	return $?
}
#######################################################################################
#
# lowercase - convert string to lowercase letters
#
# parameters:
#   none
#
# stdin:
#   input data to be translated ... only ASCII characters are handled correctly
#
# stdout:
#   input data with each occurence of 'A' to 'Z' translated to 'a' to 'z'
#
# return code:
#   0 - stdout value is valid
#   1 - error occured, usally stdin isn't a valid stream or 'tr' finished with errors
#
#######################################################################################
yf_uppercase()
{
	tr "abcdefghijklmnopqrstuvwxyz" "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	return $?
}
#######################################################################################
#
# pack - create a packed complex data structure from basic data types
#
# parameters:
#   the input parameters are a list of type-value pairs representing the data to be
#   packed to the resulting structure
#
# types:
# - the first item in such type-value pairs is the desired type and it's simply the 
#   number of bits in the output "value" - 8 for "one byte", "16" for "two byte values"
#   (short integers, signed or unsigned) and "32" for "four byte values"
# - beneath these "basic" types there are some more complex input types:
#   STR - the value is a character string (don't forget to use proper escapes there)
#   IP  - same as IP4
#   IP4 - the value is an IPv4 address and is encoded to binary (32 bit value) by 
#         yf_ipv4addr (see above) - it's "big endian" unless modified by "L" prefix
#
# modifiers:
# - values with more than 8 bit size are affected by the "endianess" of the system - 
#   it's the order in which multi-byte values are stored
# - without any modifier the resulting data is stored in the order, which the system
#   we're running on uses
# - to set up an explicit order (e.g. "network" (BE) order on an LE host) you may
#   specify a "prefix" character (L or B in mixed case) - "B32" is a 32-bit value in
#   BE and "L8" is valid (but useless, because a single byte value cannot be swapped)
#   and even the "STR" type could be prefix (the prefix will be silently ignored there)
#
# stdout:
#   binary content of the packed structure, suitable to be written to a file/pipe
#
# return code:
#   0 - stdout value is valid
#   1 - error occured, generally an invalid parameter was specified
#
#######################################################################################
yf_pack()
{
	local out="" val type hex endian 
	while [ ${#1} -gt 0 ]; do
		type="$1"
		val="$2"
		shift 2
		endian=$(echo ${type:0:1} | yf_uppercase)
		if [ -z ${endian/[LB]/} ]; then
			type="${type:1}"
		else
			unset endian
		fi
		case $type in
			8)
				hex="$(yf_dec2hex $val 1)"
				[ $? -ne 0 ] && return 1
				;;
			16)
				hex="$(yf_dec2hex $val 2)"
				[ $? -ne 0 ] && return 1
				;;
			32)
				hex="$(yf_dec2hex $val 4)"
				[ $? -ne 0 ] && return 1
				;;
			IP|IP4)
				hex="$(yf_ipv4addr $val)"
				[ $? -ne 0 ] && return 1
				[ -z $endian ] && endian=B
				;;
			STR)
				hex="$(yf_str2hex "$val")"
				unset endian
				;;
			*)
				return 1
				;;
		esac
		if [ ! -z $endian ]; then
			if [ $endian == L ]; then
				hex="$(yf_reverse_hex "$hex")"				
			fi
		else
			if [ $(yf_endianess) == L ]; then
				hex="$(yf_reverse_hex "$hex")"
			fi
		fi
		out="$out$hex"
	done
	yf_hex2bin "$out"
	return 0
}
#######################################################################################
#
# print_ip - print an IPv4 address in dotted-decimal format 
#
# parameters:
#   $1 - string representing the IPv4 address in hexadecimal format (big endian)
#
# stdout:
#   the decimal representation of the specified address as 4 decimal numbers separated
#   by dots
#
# return code:
#   0 - stdout value is valid
#   1 - error occured, the specified parameter isn't a valid hexadecimal string
#
#######################################################################################
yf_print_ip()
{
	local ip="$1" i1 i2 i3 i4
	[ ${#ip} -ne 8 ] && return 1
	while [ ${#ip} -gt 0 ]; do
		printf "%u" $(yf_hex2dec "${ip:0:2}")
		ip="${ip:2}"
		[ ${#ip} -gt 0 ] && printf "."
	done
	return 0
}
#######################################################################################
#
# network_interfaces - get the name(s) of all network interfaces from /proc/net/dev 
#
# parameters:
#   none
#
# stdout:
#   the names of network interfaces ('lo' will be filtered out)
#
# return code:
#   alwasy 0 - the list will be empty in case of an error (e.g. /proc inaccessible)
#
#######################################################################################
yf_network_interfaces()
{
	sed -n -e "s|^[ ]*\([^:]*\):.*|\1|p" /proc/net/dev | grep -v "lo" | sed -e ':x;$!N;s/\n/ /;tx'
	return 0
}
#######################################################################################
#
# wireless_interfaces - get the name(s) of all wireless interfaces from 
#                       /proc/net/wireless
#
# parameters:
#   none
#
# stdout:
#   the names of wireless interfaces
#
# return code:
#   alwasy 0 - the list will be empty in case of an error (e.g. /proc inaccessible)
#
#######################################################################################
yf_wireless_interfaces()
{
	sed -n -e "s|^[ ]*\([^:]*\):.*|\1|p" /proc/net/wireless
	return 0
}
#######################################################################################
#
# is_wireless - check, if the specified interface name is for a wireless one
#
# parameters:
#   $1 - interface to be checked
#
# return code:
#   0 - the interface is listed in /proc/net/wireless
#   1 - the interface isn't listed in /proc/net/wireless
#
#######################################################################################
yf_is_wireless_interface()
{
	local if="$(sed -n -e "s|^[ ]*\($1\):.*|\1|p" /proc/net/wireless)"
	[ ${#if} -eq 0 ] && return 1 || return 0
}

